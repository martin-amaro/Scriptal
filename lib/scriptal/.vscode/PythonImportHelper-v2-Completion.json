[
    {
        "label": "re,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re.",
        "description": "re.",
        "detail": "re.",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "datetime,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime.",
        "description": "datetime.",
        "detail": "datetime.",
        "documentation": {}
    },
    {
        "label": "tz",
        "importPath": "dateutil",
        "description": "dateutil",
        "isExtraImport": true,
        "detail": "dateutil",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "aiohttp",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aiohttp",
        "description": "aiohttp",
        "detail": "aiohttp",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "json,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json.",
        "description": "json.",
        "detail": "json.",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "ThreadPoolExecutor",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "math,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math.",
        "description": "math.",
        "detail": "math.",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "threading,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading.",
        "description": "threading.",
        "detail": "threading.",
        "documentation": {}
    },
    {
        "label": "Translator",
        "importPath": "googletrans",
        "description": "googletrans",
        "isExtraImport": true,
        "detail": "googletrans",
        "documentation": {}
    },
    {
        "label": "LANGCODES",
        "importPath": "googletrans",
        "description": "googletrans",
        "isExtraImport": true,
        "detail": "googletrans",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sys,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys.",
        "description": "sys.",
        "detail": "sys.",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "init",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "Fore",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "Style",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "get_all_commands",
        "importPath": "mapy.utils.data_utils",
        "description": "mapy.utils.data_utils",
        "isExtraImport": true,
        "detail": "mapy.utils.data_utils",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "get_all_commands",
        "importPath": "mapy.parser.utils",
        "description": "mapy.parser.utils",
        "isExtraImport": true,
        "detail": "mapy.parser.utils",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "cmd_find",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_find(c:context):\n    return set_return( find_in(c.arg(1), c.arg(3)), c.arg(5))\ndef cmd_count(c:context):\n    return set_return(count_in(c.arg(1), c.arg(3)), c.arg(5))\ndef cmd_contains(c:context):\n    return set_return(c.arg(1) in c.arg(3), c.arg(5))\ndef cmd_sort(c:context):\n    c.arg(1).sort()\n    return c.arg(1)\ndef cmd_extract(c:context):",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_count",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_count(c:context):\n    return set_return(count_in(c.arg(1), c.arg(3)), c.arg(5))\ndef cmd_contains(c:context):\n    return set_return(c.arg(1) in c.arg(3), c.arg(5))\ndef cmd_sort(c:context):\n    c.arg(1).sort()\n    return c.arg(1)\ndef cmd_extract(c:context):\n    # EXTRACT FROM 1 TO 5 IN $text\n    # EXTRACT BETWEEN 1 AND 5 IN $text",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_contains",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_contains(c:context):\n    return set_return(c.arg(1) in c.arg(3), c.arg(5))\ndef cmd_sort(c:context):\n    c.arg(1).sort()\n    return c.arg(1)\ndef cmd_extract(c:context):\n    # EXTRACT FROM 1 TO 5 IN $text\n    # EXTRACT BETWEEN 1 AND 5 IN $text\n    start = c.arg(2)\n    end = c.arg(4)",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_sort",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_sort(c:context):\n    c.arg(1).sort()\n    return c.arg(1)\ndef cmd_extract(c:context):\n    # EXTRACT FROM 1 TO 5 IN $text\n    # EXTRACT BETWEEN 1 AND 5 IN $text\n    start = c.arg(2)\n    end = c.arg(4)\n    src = c.arg(6)\n    var = c.arg(8)",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_extract",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_extract(c:context):\n    # EXTRACT FROM 1 TO 5 IN $text\n    # EXTRACT BETWEEN 1 AND 5 IN $text\n    start = c.arg(2)\n    end = c.arg(4)\n    src = c.arg(6)\n    var = c.arg(8)\n    try:\n        if c.syntax in (1, 2):\n            start -= 1",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_extract_start",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_extract_start(c:context):\n    try:\n        num = c.arg(2)\n        src = c.arg(4)\n        return set_return(src[:num], c.arg(6))\n    except IndexError:\n        throw(e.INDEX_ERROR)\ndef cmd_extract_end(c:context):\n    try:\n        num = c.arg(2)",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_extract_end",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_extract_end(c:context):\n    try:\n        num = c.arg(2)\n        src = c.arg(4)\n        return set_return(src[-num:], c.arg(6))\n    except IndexError:\n        throw(e.INDEX_ERROR)\ndef cmd_remove_first(c:context): \n    array = c.arg(1)\n    if len(array) == 0:",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_remove_first",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_remove_first(c:context): \n    array = c.arg(1)\n    if len(array) == 0:\n        throw(e.INDEX_ERROR)\n    return array.pop(0)\ndef cmd_remove_last(c:context):\n    array = c.arg(1)\n    if len(array) == 0:\n        throw(e.INDEX_ERROR)\n    return array.pop()",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_remove_last",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_remove_last(c:context):\n    array = c.arg(1)\n    if len(array) == 0:\n        throw(e.INDEX_ERROR)\n    return array.pop()\ndef cmd_unique(c:context):\n    seen = set()\n    result = []\n    for item in c.arg(1):\n        if item not in seen:",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_unique",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_unique(c:context):\n    seen = set()\n    result = []\n    for item in c.arg(1):\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return set_return(result, c.arg(3))\ndef cmd_concat(c:context):\n    if c.syntax in (1, 2):",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_concat",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_concat(c:context):\n    if c.syntax in (1, 2):\n        return set_return(c.arg(1) + c.arg(3), c.arg(5))\ndef cmd_extend(c:context):\n    c.arg(1).extend(c.arg(3))\ndef cmd_flatten(c:context):\n    return set_return(list(flatten(c.arg(1))), c.arg(3))\ndef cmd_intersect(c:context):\n    return set_return(list(set(c.arg(1)) & set(c.arg(3))), c.arg(5))\ndef cmd_union(c:context):",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_extend",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_extend(c:context):\n    c.arg(1).extend(c.arg(3))\ndef cmd_flatten(c:context):\n    return set_return(list(flatten(c.arg(1))), c.arg(3))\ndef cmd_intersect(c:context):\n    return set_return(list(set(c.arg(1)) & set(c.arg(3))), c.arg(5))\ndef cmd_union(c:context):\n    return set_return(list(set(c.arg(1)) | set(c.arg(3))), c.arg(5))\ndef cmd_merge(c:context): # Update error\n    d1 = c.arg(1)",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_flatten",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_flatten(c:context):\n    return set_return(list(flatten(c.arg(1))), c.arg(3))\ndef cmd_intersect(c:context):\n    return set_return(list(set(c.arg(1)) & set(c.arg(3))), c.arg(5))\ndef cmd_union(c:context):\n    return set_return(list(set(c.arg(1)) | set(c.arg(3))), c.arg(5))\ndef cmd_merge(c:context): # Update error\n    d1 = c.arg(1)\n    d2 = c.arg(3)\n    if isinstance(d1, list) and isinstance(d2, list):",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_intersect",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_intersect(c:context):\n    return set_return(list(set(c.arg(1)) & set(c.arg(3))), c.arg(5))\ndef cmd_union(c:context):\n    return set_return(list(set(c.arg(1)) | set(c.arg(3))), c.arg(5))\ndef cmd_merge(c:context): # Update error\n    d1 = c.arg(1)\n    d2 = c.arg(3)\n    if isinstance(d1, list) and isinstance(d2, list):\n        return set_return(d1 + d2, c.arg(5))\n    elif isinstance(d1, dict) and isinstance(d2, dict):",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_union",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_union(c:context):\n    return set_return(list(set(c.arg(1)) | set(c.arg(3))), c.arg(5))\ndef cmd_merge(c:context): # Update error\n    d1 = c.arg(1)\n    d2 = c.arg(3)\n    if isinstance(d1, list) and isinstance(d2, list):\n        return set_return(d1 + d2, c.arg(5))\n    elif isinstance(d1, dict) and isinstance(d2, dict):\n        merged = d1.copy()\n        merged.update(d2)",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_merge",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_merge(c:context): # Update error\n    d1 = c.arg(1)\n    d2 = c.arg(3)\n    if isinstance(d1, list) and isinstance(d2, list):\n        return set_return(d1 + d2, c.arg(5))\n    elif isinstance(d1, dict) and isinstance(d2, dict):\n        merged = d1.copy()\n        merged.update(d2)\n        return set_return(merged, c.arg(5))\n    else:",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_shuffle",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_shuffle(c:context):\n    import random\n    random.shuffle(c.arg(1))\n    return c.arg(1)\ndef cmd_difference(c:context):\n    return set_return(list(set(c.arg(1)) - set(c.arg(3))), c.arg(5))\ndef cmd_chunk(c:context):\n    validate_n_gt(3, Label.SIZE, c.arg(3), 0)\n    return set_return([c.arg(1)[i:i + c.arg(3)] for i in range(0, len(c.arg(1)), c.arg(3))], c.arg(5))\ndef cmd_duplicates(c:context):",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_difference",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_difference(c:context):\n    return set_return(list(set(c.arg(1)) - set(c.arg(3))), c.arg(5))\ndef cmd_chunk(c:context):\n    validate_n_gt(3, Label.SIZE, c.arg(3), 0)\n    return set_return([c.arg(1)[i:i + c.arg(3)] for i in range(0, len(c.arg(1)), c.arg(3))], c.arg(5))\ndef cmd_duplicates(c:context):\n    seen = set()\n    return set_return(list(set(x for x in c.arg(2) if x in seen or seen.add(x))), c.arg(4))\ndef cmd_clean(c:context):\n    data = c.arg(1)",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_chunk",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_chunk(c:context):\n    validate_n_gt(3, Label.SIZE, c.arg(3), 0)\n    return set_return([c.arg(1)[i:i + c.arg(3)] for i in range(0, len(c.arg(1)), c.arg(3))], c.arg(5))\ndef cmd_duplicates(c:context):\n    seen = set()\n    return set_return(list(set(x for x in c.arg(2) if x in seen or seen.add(x))), c.arg(4))\ndef cmd_clean(c:context):\n    data = c.arg(1)\n    if isinstance(data, list):\n        return set_return([elem for elem in data if elem], c.arg(3))",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_duplicates",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_duplicates(c:context):\n    seen = set()\n    return set_return(list(set(x for x in c.arg(2) if x in seen or seen.add(x))), c.arg(4))\ndef cmd_clean(c:context):\n    data = c.arg(1)\n    if isinstance(data, list):\n        return set_return([elem for elem in data if elem], c.arg(3))\n    else:\n        return set_return(re.sub(r'\\s+', ' ', data).strip(), c.arg(3))\ndef cmd_apply(c:context):",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_clean",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_clean(c:context):\n    data = c.arg(1)\n    if isinstance(data, list):\n        return set_return([elem for elem in data if elem], c.arg(3))\n    else:\n        return set_return(re.sub(r'\\s+', ' ', data).strip(), c.arg(3))\ndef cmd_apply(c:context):\n    from ...execute import execute_internal_line\n    cmd = c.arg(3)\n    arr = c.arg(1)",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_apply",
        "kind": 2,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "def cmd_apply(c:context):\n    from ...execute import execute_internal_line\n    cmd = c.arg(3)\n    arr = c.arg(1)\n    res = []\n    ALL_COMMANDS = get_all_commands()\n    if cmd in ALL_COMMANDS:\n        for item in arr:\n            inst = internal_instance(item)\n            if inst == Return.NONE:",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "commands.core.arrstr",
        "description": "commands.core.arrstr",
        "peekOfCode": "__all__ = [\n    \"cmd_find\",\n    \"cmd_count\",\n    \"cmd_contains\",\n    \"cmd_sort\",\n    \"cmd_extract\",\n    \"cmd_extract_start\",\n    \"cmd_extract_end\",\n    \"cmd_remove_first\",\n    \"cmd_remove_last\",",
        "detail": "commands.core.arrstr",
        "documentation": {}
    },
    {
        "label": "cmd_is_str",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_str(c:context): \n    return set_return(isinstance(c.arg(1), str), c.arg(3))\ndef cmd_is_num(c:context):\n    return set_return(isinstance(c.arg(1), (str, float)), c.arg(3))\ndef cmd_is_int(c:context):\n    return set_return(isinstance(c.arg(1), int), c.arg(3))\ndef cmd_is_float(c:context):\n    return set_return(isinstance(c.arg(1), float), c.arg(3))\ndef cmd_is_array(c:context):\n    return set_return(isinstance(c.arg(1), list), c.arg(3))",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_num",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_num(c:context):\n    return set_return(isinstance(c.arg(1), (str, float)), c.arg(3))\ndef cmd_is_int(c:context):\n    return set_return(isinstance(c.arg(1), int), c.arg(3))\ndef cmd_is_float(c:context):\n    return set_return(isinstance(c.arg(1), float), c.arg(3))\ndef cmd_is_array(c:context):\n    return set_return(isinstance(c.arg(1), list), c.arg(3))\ndef cmd_is_map(c:context):\n    return set_return(isinstance(c.arg(1), dict), c.arg(3))",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_int",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_int(c:context):\n    return set_return(isinstance(c.arg(1), int), c.arg(3))\ndef cmd_is_float(c:context):\n    return set_return(isinstance(c.arg(1), float), c.arg(3))\ndef cmd_is_array(c:context):\n    return set_return(isinstance(c.arg(1), list), c.arg(3))\ndef cmd_is_map(c:context):\n    return set_return(isinstance(c.arg(1), dict), c.arg(3))\ndef cmd_is_bool(c:context):\n    return set_return(isinstance(c.arg(1), bool), c.arg(3))",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_float",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_float(c:context):\n    return set_return(isinstance(c.arg(1), float), c.arg(3))\ndef cmd_is_array(c:context):\n    return set_return(isinstance(c.arg(1), list), c.arg(3))\ndef cmd_is_map(c:context):\n    return set_return(isinstance(c.arg(1), dict), c.arg(3))\ndef cmd_is_bool(c:context):\n    return set_return(isinstance(c.arg(1), bool), c.arg(3))\ndef cmd_is_reg(c:context):\n    return set_return(isinstance(c.arg(1), re.Pattern), c.arg(3))",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_array",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_array(c:context):\n    return set_return(isinstance(c.arg(1), list), c.arg(3))\ndef cmd_is_map(c:context):\n    return set_return(isinstance(c.arg(1), dict), c.arg(3))\ndef cmd_is_bool(c:context):\n    return set_return(isinstance(c.arg(1), bool), c.arg(3))\ndef cmd_is_reg(c:context):\n    return set_return(isinstance(c.arg(1), re.Pattern), c.arg(3))\ndef cmd_is_empty(c:context):\n    return set_return(is_empty(c.arg(1)), c.arg(3))",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_map",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_map(c:context):\n    return set_return(isinstance(c.arg(1), dict), c.arg(3))\ndef cmd_is_bool(c:context):\n    return set_return(isinstance(c.arg(1), bool), c.arg(3))\ndef cmd_is_reg(c:context):\n    return set_return(isinstance(c.arg(1), re.Pattern), c.arg(3))\ndef cmd_is_empty(c:context):\n    return set_return(is_empty(c.arg(1)), c.arg(3))\ndef cmd_is_inf(c:context):\n    return set_return(isinstance(c.arg(1), (int, float)) and math.isinf(c.arg(1)), c.arg(3))",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_bool",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_bool(c:context):\n    return set_return(isinstance(c.arg(1), bool), c.arg(3))\ndef cmd_is_reg(c:context):\n    return set_return(isinstance(c.arg(1), re.Pattern), c.arg(3))\ndef cmd_is_empty(c:context):\n    return set_return(is_empty(c.arg(1)), c.arg(3))\ndef cmd_is_inf(c:context):\n    return set_return(isinstance(c.arg(1), (int, float)) and math.isinf(c.arg(1)), c.arg(3))\ndef cmd_is_nan(c:context):\n    return set_return(isinstance(c.arg(1), (int, float)) and math.isnan(c.arg(1)), c.arg(3))",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_reg",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_reg(c:context):\n    return set_return(isinstance(c.arg(1), re.Pattern), c.arg(3))\ndef cmd_is_empty(c:context):\n    return set_return(is_empty(c.arg(1)), c.arg(3))\ndef cmd_is_inf(c:context):\n    return set_return(isinstance(c.arg(1), (int, float)) and math.isinf(c.arg(1)), c.arg(3))\ndef cmd_is_nan(c:context):\n    return set_return(isinstance(c.arg(1), (int, float)) and math.isnan(c.arg(1)), c.arg(3))\ndef cmd_is_date(c:context):\n    return set_return(validate_date(c.arg(1)), c.arg(3))",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_empty",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_empty(c:context):\n    return set_return(is_empty(c.arg(1)), c.arg(3))\ndef cmd_is_inf(c:context):\n    return set_return(isinstance(c.arg(1), (int, float)) and math.isinf(c.arg(1)), c.arg(3))\ndef cmd_is_nan(c:context):\n    return set_return(isinstance(c.arg(1), (int, float)) and math.isnan(c.arg(1)), c.arg(3))\ndef cmd_is_date(c:context):\n    return set_return(validate_date(c.arg(1)), c.arg(3))\n# Strings\ndef cmd_is_url(c:context):",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_inf",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_inf(c:context):\n    return set_return(isinstance(c.arg(1), (int, float)) and math.isinf(c.arg(1)), c.arg(3))\ndef cmd_is_nan(c:context):\n    return set_return(isinstance(c.arg(1), (int, float)) and math.isnan(c.arg(1)), c.arg(3))\ndef cmd_is_date(c:context):\n    return set_return(validate_date(c.arg(1)), c.arg(3))\n# Strings\ndef cmd_is_url(c:context):\n    return set_return(validate_url(c.arg(1)), c.arg(3))\ndef cmd_is_email(c:context):",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_nan",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_nan(c:context):\n    return set_return(isinstance(c.arg(1), (int, float)) and math.isnan(c.arg(1)), c.arg(3))\ndef cmd_is_date(c:context):\n    return set_return(validate_date(c.arg(1)), c.arg(3))\n# Strings\ndef cmd_is_url(c:context):\n    return set_return(validate_url(c.arg(1)), c.arg(3))\ndef cmd_is_email(c:context):\n    email = r\"^[\\w\\.-]+@([\\w-]+\\.)+[a-zA-Z]{2,}$\"\n    return set_return(bool(re.fullmatch(email, c.arg(1))), c.arg(3))",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_date",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_date(c:context):\n    return set_return(validate_date(c.arg(1)), c.arg(3))\n# Strings\ndef cmd_is_url(c:context):\n    return set_return(validate_url(c.arg(1)), c.arg(3))\ndef cmd_is_email(c:context):\n    email = r\"^[\\w\\.-]+@([\\w-]+\\.)+[a-zA-Z]{2,}$\"\n    return set_return(bool(re.fullmatch(email, c.arg(1))), c.arg(3))\ndef cmd_is_digit(c:context):\n    return set_return(c.arg(1).isdigit(), c.arg(3))",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_url",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_url(c:context):\n    return set_return(validate_url(c.arg(1)), c.arg(3))\ndef cmd_is_email(c:context):\n    email = r\"^[\\w\\.-]+@([\\w-]+\\.)+[a-zA-Z]{2,}$\"\n    return set_return(bool(re.fullmatch(email, c.arg(1))), c.arg(3))\ndef cmd_is_digit(c:context):\n    return set_return(c.arg(1).isdigit(), c.arg(3))\ndef cmd_is_dec(c:context):\n    try:\n        float(c.arg(1))",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_email",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_email(c:context):\n    email = r\"^[\\w\\.-]+@([\\w-]+\\.)+[a-zA-Z]{2,}$\"\n    return set_return(bool(re.fullmatch(email, c.arg(1))), c.arg(3))\ndef cmd_is_digit(c:context):\n    return set_return(c.arg(1).isdigit(), c.arg(3))\ndef cmd_is_dec(c:context):\n    try:\n        float(c.arg(1))\n        value = True\n    except ValueError:",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_digit",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_digit(c:context):\n    return set_return(c.arg(1).isdigit(), c.arg(3))\ndef cmd_is_dec(c:context):\n    try:\n        float(c.arg(1))\n        value = True\n    except ValueError:\n        value = False\n    return set_return(value, c.arg(3))\ndef cmd_is_numeric(c:context):",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_dec",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_dec(c:context):\n    try:\n        float(c.arg(1))\n        value = True\n    except ValueError:\n        value = False\n    return set_return(value, c.arg(3))\ndef cmd_is_numeric(c:context):\n    data:str = c.arg(1)\n    if data.isnumeric():",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_numeric",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_numeric(c:context):\n    data:str = c.arg(1)\n    if data.isnumeric():\n        value = True\n    else:\n        try:\n            num = float(data)\n            value = True\n            if num == float('inf') or num == float('-inf') or num != value:\n                value = False",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_alpha",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_alpha(c:context):\n    return set_return(c.arg(1).isalpha(), c.arg(3))\ndef cmd_is_alnum(c:context):\n    return set_return(c.arg(1).isalnum(), c.arg(3))\ndef cmd_is_upper(c:context):\n    return set_return(c.arg(1).isupper(), c.arg(3))\ndef cmd_is_lower(c:context):\n    return set_return(c.arg(1).islower(), c.arg(3))\ndef cmd_is_title(c:context):\n    return set_return(c.arg(1).istitle(), c.arg(3))",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_alnum",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_alnum(c:context):\n    return set_return(c.arg(1).isalnum(), c.arg(3))\ndef cmd_is_upper(c:context):\n    return set_return(c.arg(1).isupper(), c.arg(3))\ndef cmd_is_lower(c:context):\n    return set_return(c.arg(1).islower(), c.arg(3))\ndef cmd_is_title(c:context):\n    return set_return(c.arg(1).istitle(), c.arg(3))\ndef cmd_is_decimal(c:context):\n    return set_return(c.arg(1).isdecimal(), c.arg(3))",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_upper",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_upper(c:context):\n    return set_return(c.arg(1).isupper(), c.arg(3))\ndef cmd_is_lower(c:context):\n    return set_return(c.arg(1).islower(), c.arg(3))\ndef cmd_is_title(c:context):\n    return set_return(c.arg(1).istitle(), c.arg(3))\ndef cmd_is_decimal(c:context):\n    return set_return(c.arg(1).isdecimal(), c.arg(3))\ndef cmd_is_hex(c:context):\n    try:",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_lower",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_lower(c:context):\n    return set_return(c.arg(1).islower(), c.arg(3))\ndef cmd_is_title(c:context):\n    return set_return(c.arg(1).istitle(), c.arg(3))\ndef cmd_is_decimal(c:context):\n    return set_return(c.arg(1).isdecimal(), c.arg(3))\ndef cmd_is_hex(c:context):\n    try:\n        int(c.arg(1), 16)\n        value = True",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_title",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_title(c:context):\n    return set_return(c.arg(1).istitle(), c.arg(3))\ndef cmd_is_decimal(c:context):\n    return set_return(c.arg(1).isdecimal(), c.arg(3))\ndef cmd_is_hex(c:context):\n    try:\n        int(c.arg(1), 16)\n        value = True\n    except ValueError:\n        value = False",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_decimal",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_decimal(c:context):\n    return set_return(c.arg(1).isdecimal(), c.arg(3))\ndef cmd_is_hex(c:context):\n    try:\n        int(c.arg(1), 16)\n        value = True\n    except ValueError:\n        value = False\n    return set_return(value, c.arg(3))\ndef cmd_is_ascii(c:context):",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_hex",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_hex(c:context):\n    try:\n        int(c.arg(1), 16)\n        value = True\n    except ValueError:\n        value = False\n    return set_return(value, c.arg(3))\ndef cmd_is_ascii(c:context):\n    return set_return(c.arg(1).isascii(), c.arg(3))",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_is_ascii",
        "kind": 2,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "def cmd_is_ascii(c:context):\n    return set_return(c.arg(1).isascii(), c.arg(3))",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "commands.core.compare_cmd",
        "description": "commands.core.compare_cmd",
        "peekOfCode": "__all__ = [\n    \"cmd_is_str\",\n    \"cmd_is_num\",\n    \"cmd_is_int\",\n    \"cmd_is_float\",\n    \"cmd_is_array\",\n    \"cmd_is_map\",\n    \"cmd_is_bool\",\n    \"cmd_is_reg\",\n    \"cmd_is_email\",",
        "detail": "commands.core.compare_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_core_cmds",
        "kind": 2,
        "importPath": "commands.core.core_cmd",
        "description": "commands.core.core_cmd",
        "peekOfCode": "def cmd_core_cmds(c:context):\n    print(\"Commands\",json.dumps(rt.CUSTOM_COMMANDS, indent=4))\ndef cmd_core_vars(c:context):\n    print(\"locals\",json.dumps(rt.block_scopes, indent=4))\n    print(\"vars\",json.dumps(rt.global_variables, indent=4))\n    print(\"envaars\",json.dumps(rt.envars, indent=4))\ndef cmd_core_globalcmds(c:context):\n    print(\"Global cmds\",json.dumps(rt.GLOBAL_COMMANDS, indent=4))\ndef cmd_core_globalprops(c:context):\n    print(\"Global cmds\",json.dumps(rt.GLOBAL_PROPS, indent=4))",
        "detail": "commands.core.core_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_core_vars",
        "kind": 2,
        "importPath": "commands.core.core_cmd",
        "description": "commands.core.core_cmd",
        "peekOfCode": "def cmd_core_vars(c:context):\n    print(\"locals\",json.dumps(rt.block_scopes, indent=4))\n    print(\"vars\",json.dumps(rt.global_variables, indent=4))\n    print(\"envaars\",json.dumps(rt.envars, indent=4))\ndef cmd_core_globalcmds(c:context):\n    print(\"Global cmds\",json.dumps(rt.GLOBAL_COMMANDS, indent=4))\ndef cmd_core_globalprops(c:context):\n    print(\"Global cmds\",json.dumps(rt.GLOBAL_PROPS, indent=4))\ndef cmd_core_mixo(c):\n    print(\"Modules: \",json.dumps(rt.MODULES, indent=4))",
        "detail": "commands.core.core_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_core_globalcmds",
        "kind": 2,
        "importPath": "commands.core.core_cmd",
        "description": "commands.core.core_cmd",
        "peekOfCode": "def cmd_core_globalcmds(c:context):\n    print(\"Global cmds\",json.dumps(rt.GLOBAL_COMMANDS, indent=4))\ndef cmd_core_globalprops(c:context):\n    print(\"Global cmds\",json.dumps(rt.GLOBAL_PROPS, indent=4))\ndef cmd_core_mixo(c):\n    print(\"Modules: \",json.dumps(rt.MODULES, indent=4))\ndef cmd_core_neto(c):\n    show(rt.workspace)\ndef cmd_core_test(c):\n    print(\"TEST:\", rt.working_file)",
        "detail": "commands.core.core_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_core_globalprops",
        "kind": 2,
        "importPath": "commands.core.core_cmd",
        "description": "commands.core.core_cmd",
        "peekOfCode": "def cmd_core_globalprops(c:context):\n    print(\"Global cmds\",json.dumps(rt.GLOBAL_PROPS, indent=4))\ndef cmd_core_mixo(c):\n    print(\"Modules: \",json.dumps(rt.MODULES, indent=4))\ndef cmd_core_neto(c):\n    show(rt.workspace)\ndef cmd_core_test(c):\n    print(\"TEST:\", rt.working_file)\n    print(\"TEST:\", rt.working_path)",
        "detail": "commands.core.core_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_core_mixo",
        "kind": 2,
        "importPath": "commands.core.core_cmd",
        "description": "commands.core.core_cmd",
        "peekOfCode": "def cmd_core_mixo(c):\n    print(\"Modules: \",json.dumps(rt.MODULES, indent=4))\ndef cmd_core_neto(c):\n    show(rt.workspace)\ndef cmd_core_test(c):\n    print(\"TEST:\", rt.working_file)\n    print(\"TEST:\", rt.working_path)",
        "detail": "commands.core.core_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_core_neto",
        "kind": 2,
        "importPath": "commands.core.core_cmd",
        "description": "commands.core.core_cmd",
        "peekOfCode": "def cmd_core_neto(c):\n    show(rt.workspace)\ndef cmd_core_test(c):\n    print(\"TEST:\", rt.working_file)\n    print(\"TEST:\", rt.working_path)",
        "detail": "commands.core.core_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_core_test",
        "kind": 2,
        "importPath": "commands.core.core_cmd",
        "description": "commands.core.core_cmd",
        "peekOfCode": "def cmd_core_test(c):\n    print(\"TEST:\", rt.working_file)\n    print(\"TEST:\", rt.working_path)",
        "detail": "commands.core.core_cmd",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "commands.core.core_cmd",
        "description": "commands.core.core_cmd",
        "peekOfCode": "__all__ = ['cmd_core_cmds', 'cmd_core_vars', 'cmd_core_globalcmds', 'cmd_core_globalprops', 'cmd_core_mixo', 'cmd_core_neto',]\ndef cmd_core_cmds(c:context):\n    print(\"Commands\",json.dumps(rt.CUSTOM_COMMANDS, indent=4))\ndef cmd_core_vars(c:context):\n    print(\"locals\",json.dumps(rt.block_scopes, indent=4))\n    print(\"vars\",json.dumps(rt.global_variables, indent=4))\n    print(\"envaars\",json.dumps(rt.envars, indent=4))\ndef cmd_core_globalcmds(c:context):\n    print(\"Global cmds\",json.dumps(rt.GLOBAL_COMMANDS, indent=4))\ndef cmd_core_globalprops(c:context):",
        "detail": "commands.core.core_cmd",
        "documentation": {}
    },
    {
        "label": "dataget",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def dataget(key, defs=None):\n    if defs is None and key in default:\n        defs = default[key]\n    return rt.workspace_get('Date', key, defs)\ndef dataset(key, value):\n    rt.workspace_set('Date', key, value)\nformats = [\n    'YYYY-MM-DDTHH:mm:ss',    # ISO 8601 con tiempo completo (Ej: 2024-06-23T12:00:00)\n    'YYYY-MM-DDTHH:mm:ss.SSSSSS', # ISO 8601 con tiempo completo y fracción de segundo (Ej: 2024-06-23T12:00:00.123456)\n    'YYYY-MM-DDTHH:mm:ssZ',   # ISO 8601 con tiempo completo y zona horaria Z (Ej: 2024-06-23T12:00:00Z)",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "dataset",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def dataset(key, value):\n    rt.workspace_set('Date', key, value)\nformats = [\n    'YYYY-MM-DDTHH:mm:ss',    # ISO 8601 con tiempo completo (Ej: 2024-06-23T12:00:00)\n    'YYYY-MM-DDTHH:mm:ss.SSSSSS', # ISO 8601 con tiempo completo y fracción de segundo (Ej: 2024-06-23T12:00:00.123456)\n    'YYYY-MM-DDTHH:mm:ssZ',   # ISO 8601 con tiempo completo y zona horaria Z (Ej: 2024-06-23T12:00:00Z)\n    'YYYY-MM-DD HH:mm:ss',    # Fecha y hora separadas por espacio (Ej: 2024-06-23 12:00:00)\n    'YYYY-MM-DD HH:mm:ss.SSSSSS', # Fecha y hora con fracción de segundo (Ej: 2024-06-23 12:00:00.123456)\n    'YYYY/MM/DD HH:mm:ss',    # Fecha y hora con separadores / (Ej: 2024/06/23 12:00:00)\n    'YYYY/MM/DD HH:mm:ss.SSSSSS', # Fecha y hora con separadores / y fracción de segundo (Ej: 2024/06/23 12:00:00.123456)",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_create",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_create(c: context):\n    date_input = c.arg(1)  # Obtener el parámetro como string / array\n    date_obj = None\n    if isinstance(date_input, list):\n        validate_elems(date_input, 7)\n        try:\n            date_obj = arrow.get(*date_input)\n        except (ValueError, TypeError):\n            throw(e.DATE_INVALID_COMPS)\n        except:",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_now",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_now(c: context):\n    try:\n        # Obtener la fecha y hora actuales\n        now = arrow.now(tz=dataget('timezone'))\n        map = date_to_map(now)\n        return set_return(map, c.arg(2))\n    except: throw(e.DATE_GET_ERROR)\ndef cmd_date_format(c: context):\n    if c.syntax in (1, 2):\n        format_str = dataget('format')",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_format",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_format(c: context):\n    if c.syntax in (1, 2):\n        format_str = dataget('format')\n        var = c.arg(3)\n    elif c.syntax in (3, 4):\n        format_str = c.arg(3)\n        var = c.arg(5)\n    try:\n        date_dict = c.arg(1)\n        date_obj = pack_date(date_dict)",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_formatnow",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_formatnow(c:context):\n    try:\n        now = arrow.now(tz=dataget('timezone'))\n        formatted_date = now.format(dataget('format'), locale=dataget('locale'))\n        return set_return(formatted_date, c.arg(2))\n    except: throw(e.DATE_FORMAT_ERROR)\ndef cmd_date_since(c:context):\n    date_obj = pack_date(c.arg(1))\n    if c.syntax in (1, 2):\n        try: formatted_date = date_obj.humanize(locale=dataget('locale'))",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_since",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_since(c:context):\n    date_obj = pack_date(c.arg(1))\n    if c.syntax in (1, 2):\n        try: formatted_date = date_obj.humanize(locale=dataget('locale'))\n        except: throw(e.DATE_FORMAT_ERROR)\n        return set_return(formatted_date, c.arg(3))\n    if c.syntax in (3, 4):\n        another_obj = pack_date(c.arg(3))\n        try: formatted_date = date_obj.humanize(another_obj, locale=dataget('locale'))\n        except: throw(e.DATE_FORMAT_ERROR)",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_dist",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_dist(c:context):\n    date_obj = pack_date(c.arg(1))\n    if c.syntax in (1, 2):\n        try:\n            formatted_date = date_obj.humanize(locale=dataget('locale'), only_distance=True)\n        except:\n            throw(e.DATE_FORMAT_ERROR)\n        return set_return(formatted_date, c.arg(3))\n    if c.syntax in (3, 4):\n        another_obj = pack_date(c.arg(3))",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_compare",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_compare(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    time1 = date1.timestamp()\n    time2 = date2.timestamp()\n    # Comparar las fechas\n    if time1 > time2: n = 1\n    elif time1 < time2: n = -1\n    else: n = 0\n    return set_return(n, c.arg(5))",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_before",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_before(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    return set_return(date1.timestamp() < date2.timestamp(), c.arg(5))\ndef cmd_date_after(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    return set_return(date1.timestamp() > date2.timestamp(), c.arg(5))\ndef cmd_date_equals(c:context):\n    date1 = pack_date(c.arg(1))",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_after",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_after(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    return set_return(date1.timestamp() > date2.timestamp(), c.arg(5))\ndef cmd_date_equals(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    return set_return(date1.timestamp() == date2.timestamp(), c.arg(5))\ndef cmd_date_is_leap(c:context):\n    date_obj = pack_date(c.arg(1))",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_equals",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_equals(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    return set_return(date1.timestamp() == date2.timestamp(), c.arg(5))\ndef cmd_date_is_leap(c:context):\n    date_obj = pack_date(c.arg(1))\n    is_leap = calendar.isleap(date_obj.year)\n    return set_return(is_leap, c.arg(3))\n# Differences ----\ndef cmd_date_diffyears(c:context):",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_is_leap",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_is_leap(c:context):\n    date_obj = pack_date(c.arg(1))\n    is_leap = calendar.isleap(date_obj.year)\n    return set_return(is_leap, c.arg(3))\n# Differences ----\ndef cmd_date_diffyears(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    res = date1.date().year - date2.date().year\n    return set_return(res, c.arg(5))",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_diffyears",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_diffyears(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    res = date1.date().year - date2.date().year\n    return set_return(res, c.arg(5))\ndef cmd_date_diffmonths(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    res = (date1.date().year - date2.date().year) * 12 + (date1.date().month - date2.date().month)\n    return set_return(res, c.arg(5))",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_diffmonths",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_diffmonths(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    res = (date1.date().year - date2.date().year) * 12 + (date1.date().month - date2.date().month)\n    return set_return(res, c.arg(5))\ndef cmd_date_diffweeks(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    delta = date1.date() - date2.date()\n    res = delta.days // 7",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_diffweeks",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_diffweeks(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    delta = date1.date() - date2.date()\n    res = delta.days // 7\n    return set_return(res, c.arg(5))\ndef cmd_date_diffdays(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    res = (date1.date() - date2.date()).days",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_diffdays",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_diffdays(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    res = (date1.date() - date2.date()).days\n    return set_return(res, c.arg(5))\ndef cmd_date_diffhrs(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    res = (date1 - date2).total_seconds() / 3600\n    return set_return(res, c.arg(5))",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_diffhrs",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_diffhrs(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    res = (date1 - date2).total_seconds() / 3600\n    return set_return(res, c.arg(5))\ndef cmd_date_diffmins(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    res = (date1 - date2).total_seconds() / 60\n    return set_return(res, c.arg(5))",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_diffmins",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_diffmins(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    res = (date1 - date2).total_seconds() / 60\n    return set_return(res, c.arg(5))\ndef cmd_date_diffsecs(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    res = (date1 - date2).total_seconds()\n    return set_return(res, c.arg(5))",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_diffsecs",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_diffsecs(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    res = (date1 - date2).total_seconds()\n    return set_return(res, c.arg(5))\ndef cmd_date_diffus(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    res = (date1 - date2).total_seconds() * 1_000_000\n    return set_return(res, c.arg(5))",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_diffus",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_diffus(c:context):\n    date1 = pack_date(c.arg(1))\n    date2 = pack_date(c.arg(3))\n    res = (date1 - date2).total_seconds() * 1_000_000\n    return set_return(res, c.arg(5))\n# Get Parts ----\ndef cmd_date_get_year(c:context):\n    val = date_get_comp(c.arg(1), 'year')\n    return set_return(val, c.arg(3))\ndef cmd_date_get_month(c:context):",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_year",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_year(c:context):\n    val = date_get_comp(c.arg(1), 'year')\n    return set_return(val, c.arg(3))\ndef cmd_date_get_month(c:context):\n    val = date_get_comp(c.arg(1), 'month')\n    return set_return(val, c.arg(3))\ndef cmd_date_get_day(c:context):\n    val = date_get_comp(c.arg(1), 'day')\n    return set_return(val, c.arg(3))\ndef cmd_date_get_hrs(c:context):",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_month",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_month(c:context):\n    val = date_get_comp(c.arg(1), 'month')\n    return set_return(val, c.arg(3))\ndef cmd_date_get_day(c:context):\n    val = date_get_comp(c.arg(1), 'day')\n    return set_return(val, c.arg(3))\ndef cmd_date_get_hrs(c:context):\n    val = date_get_comp(c.arg(1), 'hour')\n    return set_return(val, c.arg(3))\ndef cmd_date_get_min(c:context):",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_day",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_day(c:context):\n    val = date_get_comp(c.arg(1), 'day')\n    return set_return(val, c.arg(3))\ndef cmd_date_get_hrs(c:context):\n    val = date_get_comp(c.arg(1), 'hour')\n    return set_return(val, c.arg(3))\ndef cmd_date_get_min(c:context):\n    val = date_get_comp(c.arg(1), 'minute')\n    return set_return(val, c.arg(3))\ndef cmd_date_get_s(c:context):",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_hrs",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_hrs(c:context):\n    val = date_get_comp(c.arg(1), 'hour')\n    return set_return(val, c.arg(3))\ndef cmd_date_get_min(c:context):\n    val = date_get_comp(c.arg(1), 'minute')\n    return set_return(val, c.arg(3))\ndef cmd_date_get_s(c:context):\n    val = date_get_comp(c.arg(1), 'second')\n    return set_return(val, c.arg(3))\ndef cmd_date_get_us(c:context):",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_min",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_min(c:context):\n    val = date_get_comp(c.arg(1), 'minute')\n    return set_return(val, c.arg(3))\ndef cmd_date_get_s(c:context):\n    val = date_get_comp(c.arg(1), 'second')\n    return set_return(val, c.arg(3))\ndef cmd_date_get_us(c:context):\n    val = date_get_comp(c.arg(1), 'microsecond')\n    return set_return(val, c.arg(3))\ndef cmd_date_get_week(c:context):",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_s",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_s(c:context):\n    val = date_get_comp(c.arg(1), 'second')\n    return set_return(val, c.arg(3))\ndef cmd_date_get_us(c:context):\n    val = date_get_comp(c.arg(1), 'microsecond')\n    return set_return(val, c.arg(3))\ndef cmd_date_get_week(c:context):\n    date_obj = pack_date(c.arg(1))\n    week_number = date_obj.isocalendar()[1]  # Obtener el número de semana ISO\n    return set_return(week_number, c.arg(3))",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_us",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_us(c:context):\n    val = date_get_comp(c.arg(1), 'microsecond')\n    return set_return(val, c.arg(3))\ndef cmd_date_get_week(c:context):\n    date_obj = pack_date(c.arg(1))\n    week_number = date_obj.isocalendar()[1]  # Obtener el número de semana ISO\n    return set_return(week_number, c.arg(3))\ndef cmd_date_get_weekday(c:context):\n    date_obj = pack_date(c.arg(1))\n    weekday = date_obj.isoweekday()",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_week",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_week(c:context):\n    date_obj = pack_date(c.arg(1))\n    week_number = date_obj.isocalendar()[1]  # Obtener el número de semana ISO\n    return set_return(week_number, c.arg(3))\ndef cmd_date_get_weekday(c:context):\n    date_obj = pack_date(c.arg(1))\n    weekday = date_obj.isoweekday()\n    return set_return(weekday, c.arg(3))\ndef cmd_date_get_weekday_name(c:context):\n    date_obj = pack_date(c.arg(1))",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_weekday",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_weekday(c:context):\n    date_obj = pack_date(c.arg(1))\n    weekday = date_obj.isoweekday()\n    return set_return(weekday, c.arg(3))\ndef cmd_date_get_weekday_name(c:context):\n    date_obj = pack_date(c.arg(1))\n    day_week = date_obj.format(\"dddd\", locale=dataget('locale'))\n    return set_return(day_week, c.arg(3))\ndef cmd_date_get_timestamp(c: context):\n    date = pack_date(c.arg(1))",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_weekday_name",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_weekday_name(c:context):\n    date_obj = pack_date(c.arg(1))\n    day_week = date_obj.format(\"dddd\", locale=dataget('locale'))\n    return set_return(day_week, c.arg(3))\ndef cmd_date_get_timestamp(c: context):\n    date = pack_date(c.arg(1))\n    timestamp = int(date.timestamp())\n    return set_return(timestamp, c.arg(3))\ndef cmd_date_get_days_in_month(c: context):\n    date_obj = pack_date(c.arg(1))",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_timestamp",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_timestamp(c: context):\n    date = pack_date(c.arg(1))\n    timestamp = int(date.timestamp())\n    return set_return(timestamp, c.arg(3))\ndef cmd_date_get_days_in_month(c: context):\n    date_obj = pack_date(c.arg(1))\n    year = date_obj.year\n    month = date_obj.month\n    days_in_month = calendar.monthrange(year, month)[1]\n    return set_return(days_in_month, c.arg(3))",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_days_in_month",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_days_in_month(c: context):\n    date_obj = pack_date(c.arg(1))\n    year = date_obj.year\n    month = date_obj.month\n    days_in_month = calendar.monthrange(year, month)[1]\n    return set_return(days_in_month, c.arg(3))\ndef cmd_date_get_days_in_year(c: context):\n    date_obj = pack_date(c.arg(1))\n    year = date_obj.year\n    is_leap_year = calendar.isleap(year)",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_days_in_year",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_days_in_year(c: context):\n    date_obj = pack_date(c.arg(1))\n    year = date_obj.year\n    is_leap_year = calendar.isleap(year)\n    days_in_year = 366 if is_leap_year else 365\n    return set_return(days_in_year, c.arg(3))\ndef cmd_date_get_week_of_year(c: context):\n    date_dict = c.arg(1)\n    date_obj = pack_date(date_dict)\n    week_of_year = date_obj.isocalendar()[1]  # Obtener el número de semana ISO",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_week_of_year",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_week_of_year(c: context):\n    date_dict = c.arg(1)\n    date_obj = pack_date(date_dict)\n    week_of_year = date_obj.isocalendar()[1]  # Obtener el número de semana ISO\n    return set_return(week_of_year, c.arg(3))\ndef cmd_date_get_day_of_year(c: context):\n    date_dict = c.arg(1)\n    date_obj = pack_date(date_dict)\n    day_of_year = date_obj.timetuple().tm_yday  # Obtener el número de día del año\n    return set_return(day_of_year, c.arg(3))",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_day_of_year",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_day_of_year(c: context):\n    date_dict = c.arg(1)\n    date_obj = pack_date(date_dict)\n    day_of_year = date_obj.timetuple().tm_yday  # Obtener el número de día del año\n    return set_return(day_of_year, c.arg(3))\ndef cmd_date_get_hour_of_year(c: context):\n    date_dict = c.arg(1)\n    date_obj = pack_date(date_dict)\n    start_of_year = date_obj.floor('year')\n    hours_of_year = int((date_obj - start_of_year).total_seconds() // 3600)  # Calcular horas transcurridas en el año",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_hour_of_year",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_hour_of_year(c: context):\n    date_dict = c.arg(1)\n    date_obj = pack_date(date_dict)\n    start_of_year = date_obj.floor('year')\n    hours_of_year = int((date_obj - start_of_year).total_seconds() // 3600)  # Calcular horas transcurridas en el año\n    return set_return(hours_of_year, c.arg(3))\ndef cmd_date_get_minute_of_year(c: context):\n    date_dict = c.arg(1)\n    date_obj = pack_date(date_dict)\n    start_of_year = date_obj.floor('year')",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_minute_of_year",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_minute_of_year(c: context):\n    date_dict = c.arg(1)\n    date_obj = pack_date(date_dict)\n    start_of_year = date_obj.floor('year')\n    minutes_of_year = int((date_obj - start_of_year).total_seconds() // 60)  # Calcular minutos transcurridos en el año\n    return set_return(minutes_of_year, c.arg(3))\ndef cmd_date_get_second_of_year(c: context):\n    date_dict = c.arg(1)\n    date_obj = pack_date(date_dict)\n    start_of_year = date_obj.floor('year')",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_second_of_year",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_second_of_year(c: context):\n    date_dict = c.arg(1)\n    date_obj = pack_date(date_dict)\n    start_of_year = date_obj.floor('year')\n    seconds_of_year = int((date_obj - start_of_year).total_seconds())  # Calcular segundos transcurridos en el año\n    return set_return(seconds_of_year, c.arg(3))\ndef cmd_date_get_microsecond_of_year(c: context):\n    date_dict = c.arg(1)\n    date_obj = pack_date(date_dict)\n    start_of_year = date_obj.floor('year')",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_microsecond_of_year",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_microsecond_of_year(c: context):\n    date_dict = c.arg(1)\n    date_obj = pack_date(date_dict)\n    start_of_year = date_obj.floor('year')\n    microseconds_of_year = int((date_obj - start_of_year).total_seconds() * 1_000_000)  # Calcular microsegundos transcurridos en el año\n    return set_return(microseconds_of_year, c.arg(3))\n# Settings ----\ndef cmd_date_get_tz(c: context):\n    return set_return(dataget('tzraw'), c.arg(3))\ndef cmd_date_get_format(c: context): ",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_tz",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_tz(c: context):\n    return set_return(dataget('tzraw'), c.arg(3))\ndef cmd_date_get_format(c: context): \n    return set_return(dataget('format'), c.arg(2))\ndef cmd_date_get_locale(c: context): \n    return set_return(dataget('locale'), c.arg(2))\ndef cmd_date_set_locale(c:context):\n    locale = c.arg(1)\n    try:\n        arrow.now().format('dd/mm', locale=locale)",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_format",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_format(c: context): \n    return set_return(dataget('format'), c.arg(2))\ndef cmd_date_get_locale(c: context): \n    return set_return(dataget('locale'), c.arg(2))\ndef cmd_date_set_locale(c:context):\n    locale = c.arg(1)\n    try:\n        arrow.now().format('dd/mm', locale=locale)\n        dataset('locale', locale)\n    except:",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_get_locale",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_get_locale(c: context): \n    return set_return(dataget('locale'), c.arg(2))\ndef cmd_date_set_locale(c:context):\n    locale = c.arg(1)\n    try:\n        arrow.now().format('dd/mm', locale=locale)\n        dataset('locale', locale)\n    except:\n        throw(e.INVALID_LOCALE, [locale])\ndef cmd_date_set_tz(c:context):",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_set_locale",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_set_locale(c:context):\n    locale = c.arg(1)\n    try:\n        arrow.now().format('dd/mm', locale=locale)\n        dataset('locale', locale)\n    except:\n        throw(e.INVALID_LOCALE, [locale])\ndef cmd_date_set_tz(c:context):\n    timezone_str = c.arg(1)\n    try:",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_set_tz",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_set_tz(c:context):\n    timezone_str = c.arg(1)\n    try:\n        # Intentar convertir la cadena de zona horaria a tzinfo válida\n        new_timezone = arrow.now(timezone_str).tzinfo\n        dataset('timezone', new_timezone)\n        dataset('tzraw', timezone_str)\n    except: throw(e.INVALID_DATE_FORMAT, [timezone_str])\ndef cmd_date_set_format(c:context):\n    try:",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_set_format",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_set_format(c:context):\n    try:\n        format_str = c.arg(1)\n        date_obj = arrow.now()\n        formatted_date = date_obj.format(format_str, locale=dataget('locale'))\n        dataset('format', format_str)\n    except ValueError:\n        throw(e.INVALID_DATE_FORMAT, [format_str])\n# Increments\ndef cmd_date_inc_year(c:context):",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_inc_year",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_inc_year(c:context):\n    value = date_inc(c.arg(1), 'years', c.arg(3))\n    return set_return(value, c.arg(5))\ndef cmd_date_inc_month(c:context):\n    value = date_inc(c.arg(1), 'months', c.arg(3))\n    return set_return(value, c.arg(5))\ndef cmd_date_inc_weeks(c:context):\n    value = date_inc(c.arg(1), 'weeks', c.arg(3))\n    return set_return(value, c.arg(5))\ndef cmd_date_inc_day(c:context):",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_inc_month",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_inc_month(c:context):\n    value = date_inc(c.arg(1), 'months', c.arg(3))\n    return set_return(value, c.arg(5))\ndef cmd_date_inc_weeks(c:context):\n    value = date_inc(c.arg(1), 'weeks', c.arg(3))\n    return set_return(value, c.arg(5))\ndef cmd_date_inc_day(c:context):\n    value = date_inc(c.arg(1), 'days', c.arg(3))\n    return set_return(value, c.arg(5))\ndef cmd_date_inc_hour(c:context):",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_inc_weeks",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_inc_weeks(c:context):\n    value = date_inc(c.arg(1), 'weeks', c.arg(3))\n    return set_return(value, c.arg(5))\ndef cmd_date_inc_day(c:context):\n    value = date_inc(c.arg(1), 'days', c.arg(3))\n    return set_return(value, c.arg(5))\ndef cmd_date_inc_hour(c:context):\n    value = date_inc(c.arg(1), 'hours', c.arg(3))\n    return set_return(value, c.arg(5))\ndef cmd_date_inc_minute(c:context):",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_inc_day",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_inc_day(c:context):\n    value = date_inc(c.arg(1), 'days', c.arg(3))\n    return set_return(value, c.arg(5))\ndef cmd_date_inc_hour(c:context):\n    value = date_inc(c.arg(1), 'hours', c.arg(3))\n    return set_return(value, c.arg(5))\ndef cmd_date_inc_minute(c:context):\n    value = date_inc(c.arg(1), 'minutes', c.arg(3))\n    return set_return(value, c.arg(5))\ndef cmd_date_inc_second(c:context):",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_inc_hour",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_inc_hour(c:context):\n    value = date_inc(c.arg(1), 'hours', c.arg(3))\n    return set_return(value, c.arg(5))\ndef cmd_date_inc_minute(c:context):\n    value = date_inc(c.arg(1), 'minutes', c.arg(3))\n    return set_return(value, c.arg(5))\ndef cmd_date_inc_second(c:context):\n    value = date_inc(c.arg(1), 'seconds', c.arg(3))\n    return set_return(value, c.arg(5))\ndef cmd_date_inc_us(c:context):",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_inc_minute",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_inc_minute(c:context):\n    value = date_inc(c.arg(1), 'minutes', c.arg(3))\n    return set_return(value, c.arg(5))\ndef cmd_date_inc_second(c:context):\n    value = date_inc(c.arg(1), 'seconds', c.arg(3))\n    return set_return(value, c.arg(5))\ndef cmd_date_inc_us(c:context):\n    value = date_inc(c.arg(1), 'microseconds', c.arg(3))\n    return set_return(value, c.arg(5))\n# Utils",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_inc_second",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_inc_second(c:context):\n    value = date_inc(c.arg(1), 'seconds', c.arg(3))\n    return set_return(value, c.arg(5))\ndef cmd_date_inc_us(c:context):\n    value = date_inc(c.arg(1), 'microseconds', c.arg(3))\n    return set_return(value, c.arg(5))\n# Utils\n@hcache()\ndef check_date(map):\n    if not validate_date(map):",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_date_inc_us",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def cmd_date_inc_us(c:context):\n    value = date_inc(c.arg(1), 'microseconds', c.arg(3))\n    return set_return(value, c.arg(5))\n# Utils\n@hcache()\ndef check_date(map):\n    if not validate_date(map):\n        throw(e.INVALID_DATE)\n@hcache()\ndef pack_date(map):",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "check_date",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def check_date(map):\n    if not validate_date(map):\n        throw(e.INVALID_DATE)\n@hcache()\ndef pack_date(map):\n    check_date(map)\n    result = arrow.get(datetime.datetime(\n            map[\"year\"],\n            map[\"month\"],\n            map[\"day\"],",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "pack_date",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def pack_date(map):\n    check_date(map)\n    result = arrow.get(datetime.datetime(\n            map[\"year\"],\n            map[\"month\"],\n            map[\"day\"],\n            map[\"hour\"],\n            map[\"minute\"],\n            map[\"second\"],\n            map[\"microsecond\"],",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "date_inc",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def date_inc(map, prop, amount):\n    if isinstance(amount, float):\n        throw(e.ONLY_INTEGERS_ALLOWED)\n    args = {prop: amount}\n    date_obj = pack_date(map)\n    try:\n        return date_to_map(date_obj.shift(**args))\n    except:\n        throw(e.DATE_INVALID_OPERATION)\ndef date_get_comp(map, prop):",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "date_get_comp",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def date_get_comp(map, prop):\n    date_obj = pack_date(map)\n    value = getattr(date_obj, prop)\n    return value\ndef date_to_map(date_obj):\n    this_id = get_id()\n    date_map = {\n        \"type\": \"date\",\n        \"id\": this_id,\n        \"year\": date_obj.year,",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "date_to_map",
        "kind": 2,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "def date_to_map(date_obj):\n    this_id = get_id()\n    date_map = {\n        \"type\": \"date\",\n        \"id\": this_id,\n        \"year\": date_obj.year,\n        \"month\": date_obj.month,\n        \"day\": date_obj.day,\n        \"hour\": date_obj.hour,\n        \"minute\": date_obj.minute,",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "__all__ = [\n    \"cmd_date_create\",\n    \"cmd_date_now\",\n    \"cmd_date_format\",\n    \"cmd_date_formatnow\",\n    \"cmd_date_since\",\n    \"cmd_date_dist\",\n    \"cmd_date_compare\",\n    \"cmd_date_before\",\n    \"cmd_date_after\",",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "default",
        "kind": 5,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "default = {\n    'format': 'MM/DD/YY',\n    'locale': 'en-us',\n    'timezone': tz.tzlocal(),\n    'tzraw': 'local',\n}\ndef dataget(key, defs=None):\n    if defs is None and key in default:\n        defs = default[key]\n    return rt.workspace_get('Date', key, defs)",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "formats",
        "kind": 5,
        "importPath": "commands.core.date_cmd",
        "description": "commands.core.date_cmd",
        "peekOfCode": "formats = [\n    'YYYY-MM-DDTHH:mm:ss',    # ISO 8601 con tiempo completo (Ej: 2024-06-23T12:00:00)\n    'YYYY-MM-DDTHH:mm:ss.SSSSSS', # ISO 8601 con tiempo completo y fracción de segundo (Ej: 2024-06-23T12:00:00.123456)\n    'YYYY-MM-DDTHH:mm:ssZ',   # ISO 8601 con tiempo completo y zona horaria Z (Ej: 2024-06-23T12:00:00Z)\n    'YYYY-MM-DD HH:mm:ss',    # Fecha y hora separadas por espacio (Ej: 2024-06-23 12:00:00)\n    'YYYY-MM-DD HH:mm:ss.SSSSSS', # Fecha y hora con fracción de segundo (Ej: 2024-06-23 12:00:00.123456)\n    'YYYY/MM/DD HH:mm:ss',    # Fecha y hora con separadores / (Ej: 2024/06/23 12:00:00)\n    'YYYY/MM/DD HH:mm:ss.SSSSSS', # Fecha y hora con separadores / y fracción de segundo (Ej: 2024/06/23 12:00:00.123456)\n    'YYYY-MM-DDTHH:mm:ss±HH:mm',\n    'YYYY-MM-DD',             # YYYY-MM-DD (Ej: 2024-06-23)",
        "detail": "commands.core.date_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_map_set",
        "kind": 2,
        "importPath": "commands.core.ds_cmd",
        "description": "commands.core.ds_cmd",
        "peekOfCode": "def cmd_map_set(c: context):\n    from ...execute import execute_line\n    rt.temp_active_map = c.arg(1)\n    if not var_exists(rt.temp_active_map):\n        var_set(rt.temp_active_map, {})\n    for sub in c.childBlock:\n        if isinstance(sub, (str)) and sub.startswith((Config.MAP_COMMANDS)):\n            execute_line(sub, False, False)\n        else:\n            throw(e.INVALID_MAP)",
        "detail": "commands.core.ds_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_key",
        "kind": 2,
        "importPath": "commands.core.ds_cmd",
        "description": "commands.core.ds_cmd",
        "peekOfCode": "def cmd_key(c: context):\n    map = rt.temp_active_map\n    if map is None:\n        throw(e.INVALID_MAP_COMMAND, [c.cmd])\n    current_map = var_get(map)\n    current_map.update({c.arg(1) : c.arg(3)})\ndef cmd_map_set_key(c:context):\n    map = c.arg(5)\n    map.update({c.arg(1) : c.arg(3)})\n    return map",
        "detail": "commands.core.ds_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_map_set_key",
        "kind": 2,
        "importPath": "commands.core.ds_cmd",
        "description": "commands.core.ds_cmd",
        "peekOfCode": "def cmd_map_set_key(c:context):\n    map = c.arg(5)\n    map.update({c.arg(1) : c.arg(3)})\n    return map\ndef cmd_map_get_key(c:context):\n    key = c.arg(1)\n    map = c.arg(3)\n    if not key in map:\n        throw(e.UNKNOWN_KEY, [key])\n    return set_return(map[key], c.arg(5))",
        "detail": "commands.core.ds_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_map_get_key",
        "kind": 2,
        "importPath": "commands.core.ds_cmd",
        "description": "commands.core.ds_cmd",
        "peekOfCode": "def cmd_map_get_key(c:context):\n    key = c.arg(1)\n    map = c.arg(3)\n    if not key in map:\n        throw(e.UNKNOWN_KEY, [key])\n    return set_return(map[key], c.arg(5))\ndef cmd_map_keys(c: context):\n    map = c.arg(1)\n    if isinstance(map, dict): return set_return(list(map.keys()), c.arg(3))\ndef cmd_map_values(c: context):",
        "detail": "commands.core.ds_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_map_keys",
        "kind": 2,
        "importPath": "commands.core.ds_cmd",
        "description": "commands.core.ds_cmd",
        "peekOfCode": "def cmd_map_keys(c: context):\n    map = c.arg(1)\n    if isinstance(map, dict): return set_return(list(map.keys()), c.arg(3))\ndef cmd_map_values(c: context):\n    map = c.arg(1)\n    if isinstance(map, dict): return set_return(list(map.values()), c.arg(3))\ndef cmd_key_exists(c:context): return set_return(c.arg(1) in c.arg(3), c.arg(5))\ndef cmd_update(c:context):\n    map = c.arg(1)\n    map.update(c.arg(3))",
        "detail": "commands.core.ds_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_map_values",
        "kind": 2,
        "importPath": "commands.core.ds_cmd",
        "description": "commands.core.ds_cmd",
        "peekOfCode": "def cmd_map_values(c: context):\n    map = c.arg(1)\n    if isinstance(map, dict): return set_return(list(map.values()), c.arg(3))\ndef cmd_key_exists(c:context): return set_return(c.arg(1) in c.arg(3), c.arg(5))\ndef cmd_update(c:context):\n    map = c.arg(1)\n    map.update(c.arg(3))\n    return map\ndef cmd_items(c:context): return set_return(list(c.arg(1).items()), c.arg(3))\ndef cmd_map_empty(c:context):",
        "detail": "commands.core.ds_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_key_exists",
        "kind": 2,
        "importPath": "commands.core.ds_cmd",
        "description": "commands.core.ds_cmd",
        "peekOfCode": "def cmd_key_exists(c:context): return set_return(c.arg(1) in c.arg(3), c.arg(5))\ndef cmd_update(c:context):\n    map = c.arg(1)\n    map.update(c.arg(3))\n    return map\ndef cmd_items(c:context): return set_return(list(c.arg(1).items()), c.arg(3))\ndef cmd_map_empty(c:context):\n    map = var_get(c.arg(1))\n    var_set(c.arg(1), {})\n# Arrays",
        "detail": "commands.core.ds_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_update",
        "kind": 2,
        "importPath": "commands.core.ds_cmd",
        "description": "commands.core.ds_cmd",
        "peekOfCode": "def cmd_update(c:context):\n    map = c.arg(1)\n    map.update(c.arg(3))\n    return map\ndef cmd_items(c:context): return set_return(list(c.arg(1).items()), c.arg(3))\ndef cmd_map_empty(c:context):\n    map = var_get(c.arg(1))\n    var_set(c.arg(1), {})\n# Arrays\ndef cmd_array_set(c:context):",
        "detail": "commands.core.ds_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_items",
        "kind": 2,
        "importPath": "commands.core.ds_cmd",
        "description": "commands.core.ds_cmd",
        "peekOfCode": "def cmd_items(c:context): return set_return(list(c.arg(1).items()), c.arg(3))\ndef cmd_map_empty(c:context):\n    map = var_get(c.arg(1))\n    var_set(c.arg(1), {})\n# Arrays\ndef cmd_array_set(c:context):\n    from ...execute import execute_line\n    rt.temp_active_array = c.arg(1)\n    if not var_exists(rt.temp_active_array):\n        var_set(rt.temp_active_array, [])",
        "detail": "commands.core.ds_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_map_empty",
        "kind": 2,
        "importPath": "commands.core.ds_cmd",
        "description": "commands.core.ds_cmd",
        "peekOfCode": "def cmd_map_empty(c:context):\n    map = var_get(c.arg(1))\n    var_set(c.arg(1), {})\n# Arrays\ndef cmd_array_set(c:context):\n    from ...execute import execute_line\n    rt.temp_active_array = c.arg(1)\n    if not var_exists(rt.temp_active_array):\n        var_set(rt.temp_active_array, [])\n    for sub in c.childBlock:",
        "detail": "commands.core.ds_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_array_set",
        "kind": 2,
        "importPath": "commands.core.ds_cmd",
        "description": "commands.core.ds_cmd",
        "peekOfCode": "def cmd_array_set(c:context):\n    from ...execute import execute_line\n    rt.temp_active_array = c.arg(1)\n    if not var_exists(rt.temp_active_array):\n        var_set(rt.temp_active_array, [])\n    for sub in c.childBlock:\n        if type(sub).__name__ == 'str' and sub.startswith((Config.ARRAY_COMMANDS)):\n            execute_line(sub, False, False)\n        else:\n            throw(e.INVALID_ARRAY)",
        "detail": "commands.core.ds_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_add",
        "kind": 2,
        "importPath": "commands.core.ds_cmd",
        "description": "commands.core.ds_cmd",
        "peekOfCode": "def cmd_add(c:context):\n    array = rt.temp_active_array\n    if array is None:\n        throw(e.INVALID_ARRAY_COMMAND, [c.cmd])\n    current_array = var_get(array)\n    current_array.append(c.arg(1))\ndef cmd_put(c:context):\n    array = rt.temp_active_array\n    if c.syntax in (1, 2):\n        if array is None:",
        "detail": "commands.core.ds_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_put",
        "kind": 2,
        "importPath": "commands.core.ds_cmd",
        "description": "commands.core.ds_cmd",
        "peekOfCode": "def cmd_put(c:context):\n    array = rt.temp_active_array\n    if c.syntax in (1, 2):\n        if array is None:\n            throw(e.INVALID_ARRAY_COMMAND, [c.cmd])\n        index = c.arg(3) - 1\n        current_array = var_get(array)\n        if c.syntax == 1:\n            current_array.append(c.arg(1))\n        elif c.syntax == 2:",
        "detail": "commands.core.ds_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_delete",
        "kind": 2,
        "importPath": "commands.core.ds_cmd",
        "description": "commands.core.ds_cmd",
        "peekOfCode": "def cmd_delete(c:context):\n    target = c.arg(1)\n    data = c.arg(3)\n    if target in data:\n        if isinstance(data, list):\n            data.remove(target)\n            return data\n        elif isinstance(data, dict):\n            del data[target]\n            return data",
        "detail": "commands.core.ds_cmd",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "commands.core.ds_cmd",
        "description": "commands.core.ds_cmd",
        "peekOfCode": "__all__ = [\n    \"cmd_map_set\",\n    \"cmd_key\",\n    \"cmd_map_set_key\",\n    \"cmd_map_get_key\",\n    \"cmd_map_keys\",\n    \"cmd_map_values\",\n    \"cmd_key_exists\",\n    \"cmd_update\",\n    \"cmd_items\",",
        "detail": "commands.core.ds_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_file_open",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_file_open(c:context):\n    file = wpath(c.arg(1))\n    mode = 'r+' if os.path.exists(file) else 'w+'\n    try:\n        data = open(file, mode, encoding='utf-8')\n    except:\n        throw(e.FILE_OPENING, [file])\n    file_id = len(rt.global_workspace.get('files', [])) + 1\n    file_map = {\n        'path': file,",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_file_read",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_file_read(c:context):\n    file_entry = _get_file_entry(c.arg(1))\n    data = file_entry.get('content')\n    try:\n        res = data.read()\n        return set_return(res, c.arg(3))\n    except:\n        throw(e.FILE_READING, [file_entry['path']])\ndef cmd_file_write(c:context):\n    file_entry = _get_file_entry(c.arg(1))",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_file_write",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_file_write(c:context):\n    file_entry = _get_file_entry(c.arg(1))\n    text = c.arg(3)\n    data = file_entry.get('content')\n    try:\n        data.seek(0)\n        data.write(text)\n        data.truncate()\n        return set_return(True, c.arg(4))\n    except:",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_file_append",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_file_append(c:context):\n    file_entry = _get_file_entry(c.arg(1))\n    text = c.arg(3)\n    data = file_entry.get('content')\n    file_path = file_entry.get('path')\n    try:\n        with open(file_path, 'ab') as f:\n            encoded_text = text.encode('utf-8')\n            f.write(encoded_text)\n        return set_return(True, c.arg(4))",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_file_close",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_file_close(c:context):\n    file_entry = _get_file_entry(c.arg(1))\n    data = file_entry.get('content')\n    try:\n        data.close()\n        file_entry['content'] = None\n        return set_return(True, c.arg(3))\n    except:\n        throw(e.FILE_CLOSING)\ndef cmd_file_exists(c: context):",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_file_exists",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_file_exists(c: context):\n    file = wpath(c.arg(1))\n    exists = os.path.exists(file)\n    return set_return(exists, c.arg(3))\ndef cmd_file_delete(c: context):\n    file = wpath(c.arg(1))\n    if os.path.exists(file):\n        try:\n            os.remove(file)\n            return set_return(True, c.arg(3))",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_file_delete",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_file_delete(c: context):\n    file = wpath(c.arg(1))\n    if os.path.exists(file):\n        try:\n            os.remove(file)\n            return set_return(True, c.arg(3))\n        except:\n            throw(e.FILE_DELETING, [file])\n    else:\n        throw(e.FILE_NOT_FOUNDF)",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_file_copy",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_file_copy(c: context):\n    source = wpath(c.arg(1))\n    destination = wpath(c.arg(3))\n    if os.path.exists(source):\n        try:\n            shutil.copy(source, destination)\n            return set_return(True, c.arg(4))\n        except:\n            throw(e.FILE_COPYING, [source, destination])\n    else:",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_file_move",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_file_move(c: context):\n    source = wpath(c.arg(1))\n    destination = wpath(c.arg(3))\n    if not os.path.exists(source):\n        throw(e.SOURCE_FILE_NOT_FOUND)\n    try:\n        shutil.move(source, destination)\n        return set_return(True, c.arg(5))\n    except:\n        throw(e.FILE_MOVING, [source, destination])",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_file_rename",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_file_rename(c: context):\n    old_name = wpath(c.arg(1))\n    new_name = wpath(c.arg(3))\n    if os.path.exists(old_name):\n        try:\n            os.rename(old_name, new_name)\n            return set_return(True, c.arg(5))\n        except:\n            throw(e.FILE_RENAMING, [old_name, new_name])\n    else:",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_file_size",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_file_size(c: context):\n    file = wpath(c.arg(1))\n    if os.path.exists(file):\n        try:\n            size = os.path.getsize(file)\n            return set_return(size, c.arg(3))\n        except:\n            throw(e.FILE_SIZE, [file])\n    else:\n        throw(e.FILE_NOT_FOUNDF)",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_path_filename",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_path_filename(c: context):\n    path = c.arg(1)\n    fname = os.path.basename(path)\n    return set_return(fname, c.arg(3))\ndef cmd_path_ext(c: context):\n    path = c.arg(1)\n    ext = os.path.splitext(path)[1]\n    return set_return(ext, c.arg(3))\ndef cmd_path_dir(c: context):\n    path = c.arg(1)",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_path_ext",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_path_ext(c: context):\n    path = c.arg(1)\n    ext = os.path.splitext(path)[1]\n    return set_return(ext, c.arg(3))\ndef cmd_path_dir(c: context):\n    path = c.arg(1)\n    directory = os.path.dirname(path)\n    return set_return(directory, c.arg(3))\ndef cmd_path_join(c: context):\n    parts = c.arg(1)",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_path_dir",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_path_dir(c: context):\n    path = c.arg(1)\n    directory = os.path.dirname(path)\n    return set_return(directory, c.arg(3))\ndef cmd_path_join(c: context):\n    parts = c.arg(1)\n    joined_path = os.path.join(*parts)\n    return set_return(joined_path, c.arg(3))\ndef cmd_path_absolute(c: context):\n    path = c.arg(1)",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_path_join",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_path_join(c: context):\n    parts = c.arg(1)\n    joined_path = os.path.join(*parts)\n    return set_return(joined_path, c.arg(3))\ndef cmd_path_absolute(c: context):\n    path = c.arg(1)\n    absolute_path = os.path.abspath(path)\n    return set_return(absolute_path, c.arg(3))\ndef cmd_path_relative(c: context):\n    path = wpath(c.arg(1))",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_path_absolute",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_path_absolute(c: context):\n    path = c.arg(1)\n    absolute_path = os.path.abspath(path)\n    return set_return(absolute_path, c.arg(3))\ndef cmd_path_relative(c: context):\n    path = wpath(c.arg(1))\n    if c.syntax in (1, 2):\n        start = wpath('')\n        var = c.arg(3)\n    elif c.syntax in (3, 4):",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_path_relative",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_path_relative(c: context):\n    path = wpath(c.arg(1))\n    if c.syntax in (1, 2):\n        start = wpath('')\n        var = c.arg(3)\n    elif c.syntax in (3, 4):\n        start = wpath(c.arg(3))\n        var = c.arg(5)\n    try:\n        relative_path = os.path.relpath(path, start)",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_path_parent",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_path_parent(c: context):\n    path = c.arg(1)\n    parent_dir = os.path.dirname(path)\n    return set_return(parent_dir, c.arg(3))\ndef cmd_path_normalize(c: context):\n    path = c.arg(1)\n    normalized_path = os.path.normpath(path)\n    return set_return(normalized_path, c.arg(3))\ndef cmd_path_split(c: context):\n    path = c.arg(1)",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_path_normalize",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_path_normalize(c: context):\n    path = c.arg(1)\n    normalized_path = os.path.normpath(path)\n    return set_return(normalized_path, c.arg(3))\ndef cmd_path_split(c: context):\n    path = c.arg(1)\n    fname = os.path.basename(path)\n    directory = os.path.dirname(path)\n    name, ext = os.path.splitext(fname)\n    return set_return([name, directory, ext], c.arg(3))",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_path_split",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_path_split(c: context):\n    path = c.arg(1)\n    fname = os.path.basename(path)\n    directory = os.path.dirname(path)\n    name, ext = os.path.splitext(fname)\n    return set_return([name, directory, ext], c.arg(3))\n# -- Directories ---\ndef cmd_directory_create(c: context):\n    dir_path = wpath(c.arg(1))\n    try:",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_directory_create",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_directory_create(c: context):\n    dir_path = wpath(c.arg(1))\n    try:\n        os.makedirs(dir_path, exist_ok=True)\n    except:\n        throw(e.DIR_CREATING, [dir_path])\ndef cmd_directory_delete(c:context):\n    dir_path = wpath(c.arg(1))\n    if not os.path.isdir(dir_path): \n        throw(e.DIR_NOT_FOUND, [dir_path])",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_directory_delete",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_directory_delete(c:context):\n    dir_path = wpath(c.arg(1))\n    if not os.path.isdir(dir_path): \n        throw(e.DIR_NOT_FOUND, [dir_path])\n    try:\n        shutil.rmtree(dir_path)\n    except:\n        throw(e.DIR_DELETING, [dir_path])\ndef cmd_directory_rename(c:context):\n    src_dir_path = wpath(c.arg(1))",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_directory_rename",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_directory_rename(c:context):\n    src_dir_path = wpath(c.arg(1))\n    dst_dir_path = wpath(c.arg(3))\n    if not os.path.isdir(src_dir_path): throw(e.SOURCE_DIR_NOT_FOUND)\n    if os.path.isdir(dst_dir_path): throw(e.DEST_DIR_EXISTS)\n    try:\n        os.rename(src_dir_path, dst_dir_path)\n    except:\n        throw(e.DIR_RENAMING, [src_dir_path])\ndef cmd_directory_exists(c:context):",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_directory_exists",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_directory_exists(c:context):\n    dir_path = wpath(c.arg(1))\n    exists = os.path.isdir(dir_path)\n    return set_return(exists, c.arg(3))\ndef cmd_directory_copy(c:context):\n    src_dir_path = wpath(c.arg(1))\n    dst_dir_path = wpath(c.arg(3))\n    if not os.path.isdir(src_dir_path): throw(e.SOURCE_DIR_NOT_FOUND)\n    if os.path.isdir(dst_dir_path): throw(e.DEST_DIR_EXISTS)\n    try:",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_directory_copy",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_directory_copy(c:context):\n    src_dir_path = wpath(c.arg(1))\n    dst_dir_path = wpath(c.arg(3))\n    if not os.path.isdir(src_dir_path): throw(e.SOURCE_DIR_NOT_FOUND)\n    if os.path.isdir(dst_dir_path): throw(e.DEST_DIR_EXISTS)\n    try:\n        shutil.copytree(src_dir_path, dst_dir_path)\n    except:\n        throw(e.DIR_COPYING, [src_dir_path])\ndef cmd_directory_move(c:context):",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_directory_move",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_directory_move(c:context):\n    src_dir_path = wpath(c.arg(1))\n    dst_dir_path = wpath(c.arg(3))\n    if not os.path.isdir(src_dir_path): throw(e.SOURCE_DIR_NOT_FOUND)\n    if os.path.isdir(dst_dir_path): throw(e.DEST_DIR_EXISTS)\n    try:\n        shutil.move(src_dir_path, dst_dir_path)\n    except:\n        throw(e.DIR_MOVING, [src_dir_path])\ndef cmd_directory_size(c:context):",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_directory_size",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_directory_size(c:context):\n    dir_path = wpath(c.arg(1))\n    if not os.path.isdir(dir_path): throw(e.DIR_NOT_FOUND, [dir_path])\n    try:\n        total_size = sum(\n            os.path.getsize(os.path.join(dir_path, file))\n            for file in os.listdir(dir_path)\n        )\n        return set_return(total_size, c.arg(3))\n    except:",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_directory_list",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_directory_list(c:context):\n    dir_path = wpath(c.arg(1))\n    if not os.path.isdir(dir_path): throw(e.DIR_NOT_FOUND, [dir_path])\n    try:\n        files_and_dirs = [f for f in os.listdir(dir_path)]\n        return set_return(files_and_dirs, c.arg(3))\n    except:\n        throw(e.DIR_LISTING, [dir_path])\ndef cmd_directory_list_files(c:context):\n    dir_path = wpath(c.arg(1))",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_directory_list_files",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_directory_list_files(c:context):\n    dir_path = wpath(c.arg(1))\n    if not os.path.isdir(dir_path): throw(e.DIR_NOT_FOUND, [dir_path])\n    try:\n        files = [f for f in os.listdir(dir_path) if os.path.isfile(os.path.join(dir_path, f))]\n        return set_return(files, c.arg(3))\n    except:\n        throw(e.DIR_LISTING, [dir_path])\ndef cmd_directory_list_dirs(c:context):\n    dir_path = wpath(c.arg(1))",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_directory_list_dirs",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_directory_list_dirs(c:context):\n    dir_path = wpath(c.arg(1))\n    if not os.path.isdir(dir_path): throw(e.DIR_NOT_FOUND, [dir_path])\n    try:\n        dirs = [f for f in os.listdir(dir_path) if os.path.isdir(os.path.join(dir_path, f))]\n        return set_return(dirs, c.arg(3))\n    except:\n        throw(e.DIR_LISTING, [dir_path])\n# -- JSON ---\ndef cmd_json_parse(c:context):",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_json_parse",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_json_parse(c:context):\n    json_string = c.arg(1)\n    try:\n        parsed_json = json.loads(json_string)\n        return set_return(parsed_json, c.arg(3))\n    except:\n        throw(e.JSON_PARSING)\ndef cmd_json_stringify(c:context):\n    map = c.arg(1)\n    try:",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_json_stringify",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_json_stringify(c:context):\n    map = c.arg(1)\n    try:\n        json_str = json.dumps(map)\n        return set_return(json_str, c.arg(3))\n    except:\n        throw(e.JSON_STRINGIFYING)\ndef cmd_json_pretty(c:context):\n    map = c.arg(1)\n    try:",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_json_pretty",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_json_pretty(c:context):\n    map = c.arg(1)\n    try:\n        json_str = json.dumps(map, indent=c.arg(3))\n        return set_return(json_str, c.arg(5))\n    except:\n        throw(e.JSON_STRINGIFYING)\ndef cmd_json_load(c:context):\n    file = wpath(c.arg(1))\n    try:",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_json_load",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_json_load(c:context):\n    file = wpath(c.arg(1))\n    try:\n        with open(file, 'r', encoding='utf-8') as f:\n            json_obj = json.load(f)\n    except UnicodeDecodeError:\n        # Si hay un error de codificación, intenta abrir con codificación predeterminada\n        try:\n            with open(file, 'r') as f:\n                json_obj = json.load(f)",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_json_save",
        "kind": 2,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "def cmd_json_save(c):\n    obj = c.arg(1)\n    file = wpath(c.arg(3))\n    try:\n        with open(file, 'w') as f:\n            json.dump(obj, f, indent=4)\n        return set_return(True, c.arg(5))\n    except:\n        throw(e.JSON_SAVING, [file])",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "commands.core.file_cmd",
        "description": "commands.core.file_cmd",
        "peekOfCode": "__all__ = [\n    \"cmd_file_open\",\n    \"cmd_file_read\",\n    \"cmd_file_write\",\n    \"cmd_file_append\",\n    \"cmd_file_close\",\n    \"cmd_file_exists\",\n    \"cmd_file_delete\",\n    \"cmd_file_copy\",\n    \"cmd_file_move\",",
        "detail": "commands.core.file_cmd",
        "documentation": {}
    },
    {
        "label": "dataget",
        "kind": 2,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def dataget(key, defs=None):\n    if defs is None and key in default:\n        defs = default[key]\n    return rt.workspace_get('HTTP', key, defs)\ndef dataset(key, value):\n    rt.workspace_set('HTTP', key, value)\n# -- Setting --\ndef cmd_http_header(c:context):\n    headers = c.arg(1)\n    dataset('headers', headers)",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "dataset",
        "kind": 2,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def dataset(key, value):\n    rt.workspace_set('HTTP', key, value)\n# -- Setting --\ndef cmd_http_header(c:context):\n    headers = c.arg(1)\n    dataset('headers', headers)\n    return set_return(True, c.arg(2))\ndef cmd_http_method(c):\n    method = c.arg(1).upper()\n    if method not in ('GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS', 'TRACE', 'CONNECT'):",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_http_header",
        "kind": 2,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def cmd_http_header(c:context):\n    headers = c.arg(1)\n    dataset('headers', headers)\n    return set_return(True, c.arg(2))\ndef cmd_http_method(c):\n    method = c.arg(1).upper()\n    if method not in ('GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS', 'TRACE', 'CONNECT'):\n        throw(e.HTTP_INVALID_METHOD, [method])\n    dataset('method', method)\ndef cmd_http_params(c):",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_http_method",
        "kind": 2,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def cmd_http_method(c):\n    method = c.arg(1).upper()\n    if method not in ('GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS', 'TRACE', 'CONNECT'):\n        throw(e.HTTP_INVALID_METHOD, [method])\n    dataset('method', method)\ndef cmd_http_params(c):\n    params = c.arg(1)\n    dataset('params', params)\n    return set_return(True, c.arg(2))\ndef cmd_http_data(c):",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_http_params",
        "kind": 2,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def cmd_http_params(c):\n    params = c.arg(1)\n    dataset('params', params)\n    return set_return(True, c.arg(2))\ndef cmd_http_data(c):\n    data = c.arg(1)\n    dataset('data', data)\n    return set_return(True, c.arg(2))\ndef cmd_http_timeout(c):\n    timeout = c.arg(1)",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_http_data",
        "kind": 2,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def cmd_http_data(c):\n    data = c.arg(1)\n    dataset('data', data)\n    return set_return(True, c.arg(2))\ndef cmd_http_timeout(c):\n    timeout = c.arg(1)\n    dataset('timeout', timeout)\n    return set_return(True, c.arg(2))\ndef cmd_http_reset(c):\n    dataset('headers', {})",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_http_timeout",
        "kind": 2,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def cmd_http_timeout(c):\n    timeout = c.arg(1)\n    dataset('timeout', timeout)\n    return set_return(True, c.arg(2))\ndef cmd_http_reset(c):\n    dataset('headers', {})\n    dataset('method', 'GET')\n    dataset('timeout', 30)\n    dataset('params', {})\n    dataset('data', {})",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_http_reset",
        "kind": 2,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def cmd_http_reset(c):\n    dataset('headers', {})\n    dataset('method', 'GET')\n    dataset('timeout', 30)\n    dataset('params', {})\n    dataset('data', {})\n# -- Callbacks --\ndef cmd_http_request(c):\n    url = c.arg(1)\n    method = dataget('method')",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_http_request",
        "kind": 2,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def cmd_http_request(c):\n    url = c.arg(1)\n    method = dataget('method')\n    response, _ = request(method, url)\n    return set_return(response, c.arg(3))\ndef cmd_http_request_ext(c:context):\n    url = c.arg(1)\n    method = dataget('method', def_method)\n    response, _ = request(method, url, None, 1)\n    return set_return(response, c.arg(3))",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_http_request_ext",
        "kind": 2,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def cmd_http_request_ext(c:context):\n    url = c.arg(1)\n    method = dataget('method', def_method)\n    response, _ = request(method, url, None, 1)\n    return set_return(response, c.arg(3))\ndef cmd_http_get(c:context):\n    url = c.arg(1)\n    response, _ = request('GET', url)\n    return set_return(response, c.arg(3))\ndef cmd_http_post(c:context):",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_http_get",
        "kind": 2,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def cmd_http_get(c:context):\n    url = c.arg(1)\n    response, _ = request('GET', url)\n    return set_return(response, c.arg(3))\ndef cmd_http_post(c:context):\n    url = c.arg(1)\n    response, _ = request('POST', url)\n    return set_return(response, c.arg(3))\ndef cmd_http_download(c:context):\n    url = c.arg(1)",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_http_post",
        "kind": 2,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def cmd_http_post(c:context):\n    url = c.arg(1)\n    response, _ = request('POST', url)\n    return set_return(response, c.arg(3))\ndef cmd_http_download(c:context):\n    url = c.arg(1)\n    fname = wpath(c.arg(3))\n    try:\n        with requests.get(url, stream=True) as r:\n            rt.raise_for_status()",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_http_download",
        "kind": 2,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def cmd_http_download(c:context):\n    url = c.arg(1)\n    fname = wpath(c.arg(3))\n    try:\n        with requests.get(url, stream=True) as r:\n            rt.raise_for_status()\n            with open(fname, 'wb') as f:\n                for chunk in rt.iter_content(chunk_size=8192):\n                    f.write(chunk)\n    except requests.exceptions.RequestException:",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_http_upload",
        "kind": 2,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def cmd_http_upload(c:context):\n    file_path = wpath(c.arg(1))\n    url = c.arg(3)\n    try:\n        with open(file_path, 'rb') as f:\n            files = {'file': f}\n            response_dict, call = request('POST', url, files)\n            call.raise_for_status()\n            return set_return(response_dict['content'], c.arg(5))\n    except FileNotFoundError:",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_http_options",
        "kind": 2,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def cmd_http_options(c:context):\n    res_dict = {\n        \"method\": dataget('method'),\n        \"params\": dataget('params'),\n        \"headers\": dataget('headers'),\n        \"data\": dataget('data'),\n        \"timeout\": dataget('timeout')\n    }\n    #show(rt.workspace.get('HTTP', None))\n    return set_return(res_dict, c.arg(2))",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "request",
        "kind": 2,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def request(method, url, tfiles=None, ext=False):\n    if not validate_url(url):\n        throw(e.HTTP_INVALID_URL, [url])\n    response_dict = {}\n    try:\n        response = requests.request(\n            method  = method,\n            url     = url,\n            headers = dataget('headers'),\n            params  = dataget('params'),",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "__all__ = [\n    \"cmd_http_header\",\n    \"cmd_http_method\",\n    \"cmd_http_params\",\n    \"cmd_http_data\",\n    \"cmd_http_timeout\",\n    \"cmd_http_reset\",\n    \"cmd_http_request\",\n    \"cmd_http_request_ext\",\n    \"cmd_http_trequest\",",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "def_method",
        "kind": 5,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def_method = 'GET'\ndef_headers = {}\ndef_timeout = 30\ndef_params = {}\ndef_data = {}\ndefault = {\n    'headers': {},\n    'method': 'GET',\n    'timeout': 30,\n    'params': {},",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "def_headers",
        "kind": 5,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def_headers = {}\ndef_timeout = 30\ndef_params = {}\ndef_data = {}\ndefault = {\n    'headers': {},\n    'method': 'GET',\n    'timeout': 30,\n    'params': {},\n    'data': {}",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "def_timeout",
        "kind": 5,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def_timeout = 30\ndef_params = {}\ndef_data = {}\ndefault = {\n    'headers': {},\n    'method': 'GET',\n    'timeout': 30,\n    'params': {},\n    'data': {}\n}",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "def_params",
        "kind": 5,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def_params = {}\ndef_data = {}\ndefault = {\n    'headers': {},\n    'method': 'GET',\n    'timeout': 30,\n    'params': {},\n    'data': {}\n}\ndef dataget(key, defs=None):",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "def_data",
        "kind": 5,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "def_data = {}\ndefault = {\n    'headers': {},\n    'method': 'GET',\n    'timeout': 30,\n    'params': {},\n    'data': {}\n}\ndef dataget(key, defs=None):\n    if defs is None and key in default:",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "default",
        "kind": 5,
        "importPath": "commands.core.http_cmd",
        "description": "commands.core.http_cmd",
        "peekOfCode": "default = {\n    'headers': {},\n    'method': 'GET',\n    'timeout': 30,\n    'params': {},\n    'data': {}\n}\ndef dataget(key, defs=None):\n    if defs is None and key in default:\n        defs = default[key]",
        "detail": "commands.core.http_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_input",
        "kind": 2,
        "importPath": "commands.core.io_cmd",
        "description": "commands.core.io_cmd",
        "peekOfCode": "def cmd_input(c: context):\n    if not rt.content is None: \n        throw(e.MULTIPLE_INPUT_CALL)\n    if c.syntax == 1:\n        rt.content = c.arg(1)\n        data = rt.content\n    elif c.syntax == 2:\n        file = wpath(c.arg(2))\n        data = file_read(file, True)\n        rt.content = data",
        "detail": "commands.core.io_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_output",
        "kind": 2,
        "importPath": "commands.core.io_cmd",
        "description": "commands.core.io_cmd",
        "peekOfCode": "def cmd_output(c:context):\n    filename = wpath(c.arg(1))\n    try:\n        with open(filename, 'w', encoding='utf-8') as file:\n            file.write('\\n'.join(map(str, rt.stored)))\n    except:\n        throw(e.FILE_WRITING, [filename])\ndef cmd_print(c:context):\n    value = to_string(c.arg(1))\n    print(value)",
        "detail": "commands.core.io_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_print",
        "kind": 2,
        "importPath": "commands.core.io_cmd",
        "description": "commands.core.io_cmd",
        "peekOfCode": "def cmd_print(c:context):\n    value = to_string(c.arg(1))\n    print(value)\ndef cmd_printf(c: context):\n    value = to_string(c.arg(1), 1)\n    print(value)\ndef cmd_printl(c:context):\n    value = c.arg(1)\n    print(*(to_string(x) for x in value))\ndef cmd_store(c:context):",
        "detail": "commands.core.io_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_printf",
        "kind": 2,
        "importPath": "commands.core.io_cmd",
        "description": "commands.core.io_cmd",
        "peekOfCode": "def cmd_printf(c: context):\n    value = to_string(c.arg(1), 1)\n    print(value)\ndef cmd_printl(c:context):\n    value = c.arg(1)\n    print(*(to_string(x) for x in value))\ndef cmd_store(c:context):\n    value = c.arg(1)\n    rt.stored.append(value)\n    envar_set(Envar.STORED, rt.stored)",
        "detail": "commands.core.io_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_printl",
        "kind": 2,
        "importPath": "commands.core.io_cmd",
        "description": "commands.core.io_cmd",
        "peekOfCode": "def cmd_printl(c:context):\n    value = c.arg(1)\n    print(*(to_string(x) for x in value))\ndef cmd_store(c:context):\n    value = c.arg(1)\n    rt.stored.append(value)\n    envar_set(Envar.STORED, rt.stored)",
        "detail": "commands.core.io_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_store",
        "kind": 2,
        "importPath": "commands.core.io_cmd",
        "description": "commands.core.io_cmd",
        "peekOfCode": "def cmd_store(c:context):\n    value = c.arg(1)\n    rt.stored.append(value)\n    envar_set(Envar.STORED, rt.stored)",
        "detail": "commands.core.io_cmd",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "commands.core.io_cmd",
        "description": "commands.core.io_cmd",
        "peekOfCode": "__all__ = ['cmd_input', 'cmd_output', 'cmd_print', 'cmd_printl', 'cmd_printf', 'cmd_store']\ndef cmd_input(c: context):\n    if not rt.content is None: \n        throw(e.MULTIPLE_INPUT_CALL)\n    if c.syntax == 1:\n        rt.content = c.arg(1)\n        data = rt.content\n    elif c.syntax == 2:\n        file = wpath(c.arg(2))\n        data = file_read(file, True)",
        "detail": "commands.core.io_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_iterate",
        "kind": 2,
        "importPath": "commands.core.loops_cmd",
        "description": "commands.core.loops_cmd",
        "peekOfCode": "def cmd_iterate(c: context):\n    from ...execute import execute_lines, execute_loop\n    env_context = {}\n    if c.syntax in (1, 2):\n        data = c.arg(1)\n        var = c.arg(3)\n        key = var\n        index = None\n        if isinstance(var, list):\n            if len(var) == 0:",
        "detail": "commands.core.loops_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_repeat",
        "kind": 2,
        "importPath": "commands.core.loops_cmd",
        "description": "commands.core.loops_cmd",
        "peekOfCode": "def cmd_repeat(c: context):\n    from ...execute import execute_loop\n    num = c.arg(1)\n    if num < 0 or not isinstance(num, int):\n        throw(e.INVALID_RANGE)\n    env_context = {\n        \"target\": range(1, num + 1),\n        \"index\": None,\n        \"key\": None\n    }",
        "detail": "commands.core.loops_cmd",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "commands.core.loops_cmd",
        "description": "commands.core.loops_cmd",
        "peekOfCode": "__all__ = ['cmd_iterate', 'cmd_repeat']\ndef cmd_iterate(c: context):\n    from ...execute import execute_lines, execute_loop\n    env_context = {}\n    if c.syntax in (1, 2):\n        data = c.arg(1)\n        var = c.arg(3)\n        key = var\n        index = None\n        if isinstance(var, list):",
        "detail": "commands.core.loops_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_if",
        "kind": 2,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "def cmd_if(c: context):\n    return bool(c.arg(1))\ndef cmd_define(c: context):\n    from ...execute import execute_line\n    if rt.on_definition:\n        throw(e.NESTED_COMMAND)\n    cmd_name = c.arg(1)\n    cmd_content = c.childBlock\n    # Check name\n    if cmd_name in Config.COMMANDS:",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_define",
        "kind": 2,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "def cmd_define(c: context):\n    from ...execute import execute_line\n    if rt.on_definition:\n        throw(e.NESTED_COMMAND)\n    cmd_name = c.arg(1)\n    cmd_content = c.childBlock\n    # Check name\n    if cmd_name in Config.COMMANDS:\n        throw(e.EXISTING_COMMAND, [cmd_name])\n    if cmd_name in Config.RESERVED_WORDS:",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_params",
        "kind": 2,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "def cmd_params(c: context):\n    cmd_name = rt.CURRENT_DEFINITION\n    if not cmd_name:\n        throw(e.INVALID_PARAMS_COMMAND)\n    rt.CUSTOM_SYNTAXES[cmd_name].append(build_params(c.arg(1), c.token(1)))\ndef cmd_return(c:context):\n    returned = Return.RETURN\n    return c.arg(1)\ndef cmd_break(c:context):\n    # if not rt.temp_active_loop:",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_return",
        "kind": 2,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "def cmd_return(c:context):\n    returned = Return.RETURN\n    return c.arg(1)\ndef cmd_break(c:context):\n    # if not rt.temp_active_loop:\n    #     throw(e.INVALID_BREAK_USE)\n    return Return.BREAK\ndef cmd_continue(c:context): return Return.CONTINUE\ndef cmd_wait(c:context):\n    import time",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_break",
        "kind": 2,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "def cmd_break(c:context):\n    # if not rt.temp_active_loop:\n    #     throw(e.INVALID_BREAK_USE)\n    return Return.BREAK\ndef cmd_continue(c:context): return Return.CONTINUE\ndef cmd_wait(c:context):\n    import time\n    time.sleep(c.arg(1))\ndef remove_circular_references(obj, seen=None):\n    if seen is None:",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_continue",
        "kind": 2,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "def cmd_continue(c:context): return Return.CONTINUE\ndef cmd_wait(c:context):\n    import time\n    time.sleep(c.arg(1))\ndef remove_circular_references(obj, seen=None):\n    if seen is None:\n        seen = set()\n    if id(obj) in seen:\n        return None\n    seen.add(id(obj))",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_wait",
        "kind": 2,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "def cmd_wait(c:context):\n    import time\n    time.sleep(c.arg(1))\ndef remove_circular_references(obj, seen=None):\n    if seen is None:\n        seen = set()\n    if id(obj) in seen:\n        return None\n    seen.add(id(obj))\n    if isinstance(obj, dict):",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "remove_circular_references",
        "kind": 2,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "def remove_circular_references(obj, seen=None):\n    if seen is None:\n        seen = set()\n    if id(obj) in seen:\n        return None\n    seen.add(id(obj))\n    if isinstance(obj, dict):\n        new_dict = {}\n        for k, v in obj.items():\n            new_dict[k] = remove_circular_references(v, seen)",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_catch",
        "kind": 2,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "def cmd_catch(c:context):\n    from ...execute import execute_lines\n    set_return(rt.last_error, c.arg(2))\n    return execute_lines(c.childBlock)\ndef cmd_import(c:context):\n    path = c.arg(1)\n    rpath = wpath(path)\n    file = None\n    lib = os.path.join(os.getcwd(), 'lib', path)\n    module = os.path.join(lib, path + Global.FILE_EXT)",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_import",
        "kind": 2,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "def cmd_import(c:context):\n    path = c.arg(1)\n    rpath = wpath(path)\n    file = None\n    lib = os.path.join(os.getcwd(), 'lib', path)\n    module = os.path.join(lib, path + Global.FILE_EXT)\n    # Check if file exists\n    if os.path.isfile(rpath):\n        file = rpath\n    # Add .mapy extension",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_export",
        "kind": 2,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "def cmd_export(c:context):\n    if c.syntax == 1:\n        var = c.arg(1)\n        # Log origin of variable\n        _, origin = var_get(var, origin=True) # check variable\n        if origin == 'self':\n            origin = rt.MODULES_ID.get(rt.current_runtime)\n        # Export SELF command\n        if var == f'@{Envar.SELF}':\n            export_item(rt.CURRENT_DEFINITION, 'cmd', origin)",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_error",
        "kind": 2,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "def cmd_error(c:context):\n    throwCustom(c.arg(1))\ndef cmd_throw(c:context):\n    data = c.arg(1)\n    if isinstance(data, dict):\n        type = data.get('type')\n        message = data.get('message')\n        code = data.get('code')\n        throwError(type, message, False, code)\ndef cmd_error_syn(c:context):",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_throw",
        "kind": 2,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "def cmd_throw(c:context):\n    data = c.arg(1)\n    if isinstance(data, dict):\n        type = data.get('type')\n        message = data.get('message')\n        code = data.get('code')\n        throwError(type, message, False, code)\ndef cmd_error_syn(c:context):\n    msg = get_element(c.arg(1), 0, '')\n    code = get_element(c.arg(1), 1, 'INVALID_SYNTAX')",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_error_syn",
        "kind": 2,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "def cmd_error_syn(c:context):\n    msg = get_element(c.arg(1), 0, '')\n    code = get_element(c.arg(1), 1, 'INVALID_SYNTAX')\n    return {\n        \"type\": \"SyntaxError\",\n        \"message\": msg,\n        \"code\": code\n    }\ndef cmd_error_val(c:context):\n    msg = get_element(c.arg(1), 0, '')",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_error_val",
        "kind": 2,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "def cmd_error_val(c:context):\n    msg = get_element(c.arg(1), 0, '')\n    code = get_element(c.arg(1), 1, 'INVALID_VALUE')\n    return {\n        \"type\": \"ValueError\",\n        \"message\": msg,\n        \"code\": code\n    }\ndef cmd_error_typ(c:context):\n    msg = get_element(c.arg(1), 0, '')",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_error_typ",
        "kind": 2,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "def cmd_error_typ(c:context):\n    msg = get_element(c.arg(1), 0, '')\n    code = get_element(c.arg(1), 1, 'INVALID_VALUE_TYPE')\n    return {\n        \"type\": \"TypeError\",\n        \"message\": msg,\n        \"code\": code\n    }\ndef cmd_error_rt(c:context):\n    msg = get_element(c.arg(1), 0, '')",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_error_rt",
        "kind": 2,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "def cmd_error_rt(c:context):\n    msg = get_element(c.arg(1), 0, '')\n    code = get_element(c.arg(1), 1, 'RUNTIME_ERROR')\n    return {\n        \"type\": \"Runtimerror\",\n        \"message\": msg,\n        \"code\": code\n    }\n# Utils\ndef export_item(name, type, origin):",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "export_item",
        "kind": 2,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "def export_item(name, type, origin):\n    if not name:\n        throwCustom(\"IONVALID\")\n    package = {\n        \"src\": name,\n        \"type\": type,\n        \"module\": origin\n    }\n    if package in rt.export_list:\n        throwCustom(f\"'{name}' already exported.\")",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "export_cmd",
        "kind": 2,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "def export_cmd(cmd):\n    if cmd in Config.COMMANDS:\n        throw(e.COMMAND_NOT_EXPORTABLE, [cmd])\n    elif cmd in rt.CUSTOM_COMMANDS:\n        origin = rt.MODULES_ID.get(rt.current_runtime) # self\n    elif cmd in rt.GLOBAL_COMMANDS:\n        origin = rt.GLOBAL_COMMANDS[cmd][0]\n    else:\n        throw(e.UNKNOWN_COMMAND, [cmd])\n    export_item(cmd, 'cmd', origin)",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "commands.core.main_cmd",
        "description": "commands.core.main_cmd",
        "peekOfCode": "__all__ = [\n    \"cmd_if\",\n    \"cmd_define\",\n    \"cmd_params\",\n    \"cmd_return\",\n    \"cmd_break\",\n    \"cmd_continue\",\n    \"cmd_wait\",\n    \"cmd_catch\",\n    \"cmd_import\",",
        "detail": "commands.core.main_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_sum",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_sum(c:context):\n    if c.syntax in (1, 2):\n        _sum = reduce(lambda x, y: x + y, c.arg(1))\n        return set_return(_sum, c.arg(3))\n    elif c.syntax in (3, 4):\n        return set_return(c.arg(1) + c.arg(3), c.arg(5))\ndef cmd_subtract(c:context):\n    if c.syntax in (1, 2):\n        _sub = reduce(lambda x, y: x - y, c.arg(1))\n        return set_return(_sub, c.arg(3))",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_subtract",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_subtract(c:context):\n    if c.syntax in (1, 2):\n        _sub = reduce(lambda x, y: x - y, c.arg(1))\n        return set_return(_sub, c.arg(3))\n    elif c.syntax in (3, 4):\n        return set_return(c.arg(1) - c.arg(3), c.arg(5))\ndef cmd_divide(c:context):\n    if c.syntax in (1, 2):\n        _sum = reduce(lambda x, y: x / y, c.arg(1))\n        return set_return(_sum, c.arg(3))",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_divide",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_divide(c:context):\n    if c.syntax in (1, 2):\n        _sum = reduce(lambda x, y: x / y, c.arg(1))\n        return set_return(_sum, c.arg(3))\n    elif c.syntax in (3, 4):\n        return set_return(c.arg(1) / c.arg(3), c.arg(5))\ndef cmd_multiply(c:context):\n    if c.syntax in (1, 2):\n        _sum = reduce(lambda x, y: x * y, c.arg(1))\n        return set_return(_sum, c.arg(3))",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_multiply",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_multiply(c:context):\n    if c.syntax in (1, 2):\n        _sum = reduce(lambda x, y: x * y, c.arg(1))\n        return set_return(_sum, c.arg(3))\n    elif c.syntax in (3, 4):\n        return set_return(c.arg(1) * c.arg(3), c.arg(5))\ndef cmd_increment(c:context):\n    return set_var_value(c.arg(1), '+', c.arg(3))\ndef cmd_decrement(c:context):\n    return set_var_value(c.arg(1), '-', c.arg(3))",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_increment",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_increment(c:context):\n    return set_var_value(c.arg(1), '+', c.arg(3))\ndef cmd_decrement(c:context):\n    return set_var_value(c.arg(1), '-', c.arg(3))\ndef cmd_min(c:context): \n    return set_return(min(c.arg(1)), c.arg(3))\ndef cmd_max(c:context):\n    return set_return(max(c.arg(1)), c.arg(3))\ndef cmd_bound(c:context):\n    value = c.arg(1)",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_decrement",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_decrement(c:context):\n    return set_var_value(c.arg(1), '-', c.arg(3))\ndef cmd_min(c:context): \n    return set_return(min(c.arg(1)), c.arg(3))\ndef cmd_max(c:context):\n    return set_return(max(c.arg(1)), c.arg(3))\ndef cmd_bound(c:context):\n    value = c.arg(1)\n    low = c.arg(3)\n    high = c.arg(5)",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_min",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_min(c:context): \n    return set_return(min(c.arg(1)), c.arg(3))\ndef cmd_max(c:context):\n    return set_return(max(c.arg(1)), c.arg(3))\ndef cmd_bound(c:context):\n    value = c.arg(1)\n    low = c.arg(3)\n    high = c.arg(5)\n    try:\n        return set_return(max(low, min(high, value)), c.arg(7))",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_max",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_max(c:context):\n    return set_return(max(c.arg(1)), c.arg(3))\ndef cmd_bound(c:context):\n    value = c.arg(1)\n    low = c.arg(3)\n    high = c.arg(5)\n    try:\n        return set_return(max(low, min(high, value)), c.arg(7))\n    except:\n        throw(e.INVALID_OPERATION)",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_bound",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_bound(c:context):\n    value = c.arg(1)\n    low = c.arg(3)\n    high = c.arg(5)\n    try:\n        return set_return(max(low, min(high, value)), c.arg(7))\n    except:\n        throw(e.INVALID_OPERATION)\ndef cmd_round(c:context):\n    return set_return(round(c.arg(1)), c.arg(3))",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_round",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_round(c:context):\n    return set_return(round(c.arg(1)), c.arg(3))\ndef cmd_floor(c:context):\n    try:\n        if c.syntax in (1, 2):\n            return set_return(math.floor(c.arg(1)), c.arg(3))\n        else:\n            multiplier = 10 ** c.arg(3)\n            res = math.floor(c.arg(1) * multiplier) / multiplier\n            return set_return(res, c.arg(5))",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_floor",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_floor(c:context):\n    try:\n        if c.syntax in (1, 2):\n            return set_return(math.floor(c.arg(1)), c.arg(3))\n        else:\n            multiplier = 10 ** c.arg(3)\n            res = math.floor(c.arg(1) * multiplier) / multiplier\n            return set_return(res, c.arg(5))\n    except:\n        throw(e.INVALID_OPERATION)",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_ceil",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_ceil(c:context):\n    try:\n        if c.syntax in (1, 2):\n            return set_return(math.ceil(c.arg(1)), c.arg(3))\n        else:\n            multiplier = 10 ** c.arg(3)\n            res = math.ceil(c.arg(1) * multiplier) / multiplier\n            return set_return(res, c.arg(5))\n    except:\n        throw(e.INVALID_OPERATION)",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_frac",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_frac(c:context):\n    str_n = str(c.arg(1))\n    decimal_index = str_n.find('.')\n    if decimal_index == -1: return '0.00'\n    frac = '0.' + str_n[decimal_index + 1:]\n    return set_return(frac , c.arg(3))\n# Fix\ndef cmd_fractional(c:context):\n    n = c.arg(1)\n    frac, _ = math.modf(n)",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_fractional",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_fractional(c:context):\n    n = c.arg(1)\n    frac, _ = math.modf(n)\n    return set_return(frac, c.arg(3))\ndef cmd_power(c:context):\n    return set_return(c.arg(1) ** c.arg(3), c.arg(5))\ndef cmd_sqrt(c:context): \n    if c.arg(1) < 0: throw(e.MATH_SQRT_NEGATIVE)\n    return set_return(math.sqrt(c.arg(1)), c.arg(3))\ndef cmd_mod(c:context):",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_power",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_power(c:context):\n    return set_return(c.arg(1) ** c.arg(3), c.arg(5))\ndef cmd_sqrt(c:context): \n    if c.arg(1) < 0: throw(e.MATH_SQRT_NEGATIVE)\n    return set_return(math.sqrt(c.arg(1)), c.arg(3))\ndef cmd_mod(c:context):\n    if c.arg(3) == 0: throw(e.MATH_MODULO_ZERO)\n    return set_return(c.arg(1) % c.arg(3), c.arg(5))\ndef cmd_abs(c:context):\n    try:",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_sqrt",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_sqrt(c:context): \n    if c.arg(1) < 0: throw(e.MATH_SQRT_NEGATIVE)\n    return set_return(math.sqrt(c.arg(1)), c.arg(3))\ndef cmd_mod(c:context):\n    if c.arg(3) == 0: throw(e.MATH_MODULO_ZERO)\n    return set_return(c.arg(1) % c.arg(3), c.arg(5))\ndef cmd_abs(c:context):\n    try:\n        return set_return(abs(c.arg(1)), c.arg(3))\n    except:",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_mod",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_mod(c:context):\n    if c.arg(3) == 0: throw(e.MATH_MODULO_ZERO)\n    return set_return(c.arg(1) % c.arg(3), c.arg(5))\ndef cmd_abs(c:context):\n    try:\n        return set_return(abs(c.arg(1)), c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)\ndef cmd_sin(c:context):\n    try:",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_abs",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_abs(c:context):\n    try:\n        return set_return(abs(c.arg(1)), c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)\ndef cmd_sin(c:context):\n    try:\n        return set_return(math.sin(c.arg(1)), c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_sin",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_sin(c:context):\n    try:\n        return set_return(math.sin(c.arg(1)), c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)\ndef cmd_cos(c:context):\n    try:\n        return set_return(math.cos(c.arg(1)), c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_cos",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_cos(c:context):\n    try:\n        return set_return(math.cos(c.arg(1)), c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)\ndef cmd_tan(c:context):\n    try:\n        return set_return(math.tan(c.arg(1)), c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_tan",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_tan(c:context):\n    try:\n        return set_return(math.tan(c.arg(1)), c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)\ndef cmd_log(c:context):\n    if c.arg(1) <= 0: throw(e.MATH_LOG_EMPTY, [''])\n    try:\n        return set_return(math.log(c.arg(1)), c.arg(3))\n    except:",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_log",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_log(c:context):\n    if c.arg(1) <= 0: throw(e.MATH_LOG_EMPTY, [''])\n    try:\n        return set_return(math.log(c.arg(1)), c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)\ndef cmd_log10(c:context):\n    if c.arg(1) <= 0: throw(e.MATH_LOG_EMPTY, ['base 10 '])\n    try:\n        return set_return(math.log10(c.arg(1)), c.arg(3))",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_log10",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_log10(c:context):\n    if c.arg(1) <= 0: throw(e.MATH_LOG_EMPTY, ['base 10 '])\n    try:\n        return set_return(math.log10(c.arg(1)), c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)\ndef cmd_logn(c:context):\n    base = c.arg(1)\n    n = c.arg(3)\n    if n <= 0: throw(e.MATH_LOG_EMPTY, [f'base {base} '])",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_logn",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_logn(c:context):\n    base = c.arg(1)\n    n = c.arg(3)\n    if n <= 0: throw(e.MATH_LOG_EMPTY, [f'base {base} '])\n    if base == 1: throw(e.MATH_LOG_UNDEFINED, [1])\n    if base <= 0: throw(e.MATH_LOG_EMPTY, [''])\n    try:\n        return set_return(math.log(n, base), c.arg(5))\n    except:\n        throw(e.INVALID_OPERATION)",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_exp",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_exp(c:context):\n    n = c.arg(1)\n    if n < Config.MIN_EXPONENT: throw(e.MATH_EXP_SMALL, [n])\n    if n > Config.MAX_EXPONENT: throw(e.MATH_EXP_LARGE, [n])\n    try:\n        return set_return(math.exp(n), c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)\ndef cmd_fact(c:context):\n    n = c.arg(1)",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_fact",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_fact(c:context):\n    n = c.arg(1)\n    if n < 0: throw(e.MATH_FACTORIAL_NEGATIVE, [n])\n    if isinstance(n, float):\n        throw(e.ONLY_FLOATS_ALLOWED)\n    try:\n        return set_return(math.factorial(n), c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)\ndef cmd_average(c:context):",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_average",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_average(c:context):\n    arr = c.arg(1)\n    if not arr: throw(e.EMPTY_ARRAY)\n    try:\n        _sum = sum(arr)\n        avg = _sum / len(arr)\n        return set_return(avg, c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)\ndef cmd_median(c):",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_median",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_median(c):\n    arr = c.arg(1)\n    if not arr: throw(e.EMPTY_ARRAY)\n    try:\n        return set_return(statistics.median(arr), c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)\ndef cmd_mode(c):\n    arr = c.arg(1)\n    if not arr: throw(e.EMPTY_ARRAY)",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_mode",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_mode(c):\n    arr = c.arg(1)\n    if not arr: throw(e.EMPTY_ARRAY)\n    try:\n        return set_return(statistics.mode(arr), c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)\ndef cmd_stdev(c):\n    arr = c.arg(1)\n    if len(arr) < 2: throw(e.MATH_STDEV_SMALL)",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_stdev",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_stdev(c):\n    arr = c.arg(1)\n    if len(arr) < 2: throw(e.MATH_STDEV_SMALL)\n    try:\n        return set_return(statistics.stdev(arr), c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)\ndef cmd_variance(c):\n    arr = c.arg(1)\n    if len(arr) < 2: throw(e.MATH_VARIANCE_SMALL)",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_variance",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_variance(c):\n    arr = c.arg(1)\n    if len(arr) < 2: throw(e.MATH_VARIANCE_SMALL)\n    try:\n        return set_return(statistics.variance(arr), c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)\ndef cmd_hex(c:context):\n    if not isinstance(c.arg(1), int): throw(e.ONLY_INTEGERS_ALLOWED)\n    try:",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_hex",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_hex(c:context):\n    if not isinstance(c.arg(1), int): throw(e.ONLY_INTEGERS_ALLOWED)\n    try:\n        return set_return(hex(c.arg(1))[2:].upper(), c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)\ndef cmd_bin(c:context):\n    if not isinstance(c.arg(1), int): throw(e.ONLY_INTEGERS_ALLOWED)\n    try:\n        return set_return(bin(c.arg(1))[2:], c.arg(3))",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_bin",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_bin(c:context):\n    if not isinstance(c.arg(1), int): throw(e.ONLY_INTEGERS_ALLOWED)\n    try:\n        return set_return(bin(c.arg(1))[2:], c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)\ndef cmd_oct(c:context):\n    if not isinstance(c.arg(1), int): throw(e.ONLY_INTEGERS_ALLOWED)\n    try:\n        return set_return(oct(c.arg(1))[2:], c.arg(3))",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_oct",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_oct(c:context):\n    if not isinstance(c.arg(1), int): throw(e.ONLY_INTEGERS_ALLOWED)\n    try:\n        return set_return(oct(c.arg(1))[2:], c.arg(3))\n    except:\n        throw(e.INVALID_OPERATION)\n# Back\ndef cmd_hex_dec(c:context):\n    try:\n        dec = int(c.arg(1), 16)",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_hex_dec",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_hex_dec(c:context):\n    try:\n        dec = int(c.arg(1), 16)\n        return set_return(dec, c.arg(3))\n    except ValueError:\n        throw(e.INVALID_HEXADECIMAL_STRING)\n    except:\n        throw(e.INVALID_OPERATION)\ndef cmd_bin_dec(c:context):\n    try:",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_bin_dec",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_bin_dec(c:context):\n    try:\n        dec = int(c.arg(1), 2)\n        return set_return(dec, c.arg(3))\n    except ValueError:\n        throw(e.INVALID_BINARY_STRING)\n    except:\n        throw(e.INVALID_OPERATION)\ndef cmd_oct_dec(c:context):\n    try:",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_oct_dec",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def cmd_oct_dec(c:context):\n    try:\n        dec = int(c.arg(1), 8)\n        return set_return(dec, c.arg(3))\n    except ValueError:\n        throw(e.INVALID_OCTAL_STRING)\n    except:\n        throw(e.INVALID_OPERATION)\n# --- Internals --\ndef set_var_value(varname, operator, amount = None):",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "set_var_value",
        "kind": 2,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "def set_var_value(varname, operator, amount = None):\n    value = var_get(varname)\n    n = 1 if amount is None else amount\n    result = None\n    try:\n        match operator:\n            case '+': result = value + n\n            case '-': result = value - n\n            case '*': result = value * n\n            case '/': result = value / n",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "commands.core.math_cmd",
        "description": "commands.core.math_cmd",
        "peekOfCode": "__all__ = [\n    \"cmd_sum\",\n    \"cmd_subtract\",\n    \"cmd_divide\",\n    \"cmd_multiply\",\n    \"cmd_increment\",\n    \"cmd_decrement\",\n    \"cmd_min\",\n    \"cmd_max\",\n    \"cmd_bound\",",
        "detail": "commands.core.math_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_random",
        "kind": 2,
        "importPath": "commands.core.random_cmd",
        "description": "commands.core.random_cmd",
        "peekOfCode": "def cmd_random(c:context):\n    if c.syntax in (1, 2):\n        data = c.arg(1)\n        if isinstance(data, (int, float)):\n            return set_return(random.randint(0, data - 1), c.arg(3))\n        elif isinstance(data, list):\n            return set_return(random.shuffle(data), c.arg(3))\n    if c.syntax in (3, 4):\n        try: return set_return(random.randint(c.arg(2), c.arg(4)), c.arg(6))\n        except (ValueError, TypeError): throw(e.INVALID_RANGE)",
        "detail": "commands.core.random_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_choice",
        "kind": 2,
        "importPath": "commands.core.random_cmd",
        "description": "commands.core.random_cmd",
        "peekOfCode": "def cmd_choice(c:context):\n    arr = c.arg(1)\n    if not arr: throw(e.EMPTY_ARRAY)\n    return set_return(random.choice(arr), c.arg(3))",
        "detail": "commands.core.random_cmd",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "commands.core.random_cmd",
        "description": "commands.core.random_cmd",
        "peekOfCode": "__all__ = ['cmd_random', 'cmd_choice']\ndef cmd_random(c:context):\n    if c.syntax in (1, 2):\n        data = c.arg(1)\n        if isinstance(data, (int, float)):\n            return set_return(random.randint(0, data - 1), c.arg(3))\n        elif isinstance(data, list):\n            return set_return(random.shuffle(data), c.arg(3))\n    if c.syntax in (3, 4):\n        try: return set_return(random.randint(c.arg(2), c.arg(4)), c.arg(6))",
        "detail": "commands.core.random_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_pattern",
        "kind": 2,
        "importPath": "commands.core.regex_cmd",
        "description": "commands.core.regex_cmd",
        "peekOfCode": "def cmd_pattern(c: context):  \n    raw = c.arg(1)\n    combined_flags = 0\n    slot = c.arg(3)\n    if c.syntax in (3, 4):\n        flags = c.arg(3)\n        for flag in flags:\n            if flag in Global.FLAG_CONSTANTS:\n                flag = Global.FLAG_CONSTANTS[flag]\n            if flag in Global.INVERTED_FLAG_MAP:",
        "detail": "commands.core.regex_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_pattern_info",
        "kind": 2,
        "importPath": "commands.core.regex_cmd",
        "description": "commands.core.regex_cmd",
        "peekOfCode": "def cmd_pattern_info(c: context):\n    regex = c.arg(1)\n    flags = [*get_flag(regex.flags)]\n    info = {\n        'source': regex.pattern,\n        'flags': flags\n    }\n    return set_return(info, c.arg(3))\ndef cmd_match(c: context):\n    pattern: re.Pattern = c.arg(1)",
        "detail": "commands.core.regex_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_match",
        "kind": 2,
        "importPath": "commands.core.regex_cmd",
        "description": "commands.core.regex_cmd",
        "peekOfCode": "def cmd_match(c: context):\n    pattern: re.Pattern = c.arg(1)\n    text = c.arg(3)\n    matches = pattern.findall(text)\n    matches_list = [\n        list(match) if isinstance(match, tuple) else match for match in matches\n    ]\n    return set_return(matches_list, c.arg(5))\ndef cmd_match_all(c: context):\n    pattern: re.Pattern = c.arg(1)",
        "detail": "commands.core.regex_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_match_all",
        "kind": 2,
        "importPath": "commands.core.regex_cmd",
        "description": "commands.core.regex_cmd",
        "peekOfCode": "def cmd_match_all(c: context):\n    pattern: re.Pattern = c.arg(1)\n    text = c.arg(3)\n    matches = pattern.finditer(text)\n    result = []\n    for match in matches:\n        match_info = {\n            \"match\": match.group(),\n            \"start\": match.start() + 1,\n            \"end\": match.end() + 1,",
        "detail": "commands.core.regex_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_fullmatch",
        "kind": 2,
        "importPath": "commands.core.regex_cmd",
        "description": "commands.core.regex_cmd",
        "peekOfCode": "def cmd_fullmatch(c: context):\n    pattern: re.Pattern = c.arg(1)\n    result = pattern.fullmatch(c.arg(3))\n    return set_return(bool(result), c.arg(5))\ndef cmd_nonmatch(c: context):\n    pattern = c.arg(1)\n    text = c.arg(3)\n    # Encuentra todas las coincidencias con el patrón\n    matches = list(pattern.finditer(text))\n    # Construye las partes que no coinciden con el patrón",
        "detail": "commands.core.regex_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_nonmatch",
        "kind": 2,
        "importPath": "commands.core.regex_cmd",
        "description": "commands.core.regex_cmd",
        "peekOfCode": "def cmd_nonmatch(c: context):\n    pattern = c.arg(1)\n    text = c.arg(3)\n    # Encuentra todas las coincidencias con el patrón\n    matches = list(pattern.finditer(text))\n    # Construye las partes que no coinciden con el patrón\n    non_matches = []\n    start_idx = 0\n    for match in matches:\n        # Agrega la parte antes de la coincidencia actual",
        "detail": "commands.core.regex_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_match_first",
        "kind": 2,
        "importPath": "commands.core.regex_cmd",
        "description": "commands.core.regex_cmd",
        "peekOfCode": "def cmd_match_first(c: context):\n    pattern: re.Pattern = c.arg(1)\n    text = c.arg(3)\n    match = pattern.search(text)\n    result = {}\n    if match:\n        result = {\n            \"match\": match.group(),\n            \"start\": match.start() + 1,\n            \"end\": match.end() + 1,",
        "detail": "commands.core.regex_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_flag_dt",
        "kind": 2,
        "importPath": "commands.core.regex_cmd",
        "description": "commands.core.regex_cmd",
        "peekOfCode": "def cmd_flag_dt(c: context):\n    __set_regex_flag(re.DOTALL, c.arg(1))\ndef cmd_flag_ml(c: context):\n    __set_regex_flag(re.MULTILINE, c.arg(1))\ndef cmd_flag_ic(c: context):\n    __set_regex_flag(re.IGNORECASE, c.arg(1))\n# cmd_flag_dt\n# cmd_flag_ml\n# cmd_flag_ic",
        "detail": "commands.core.regex_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_flag_ml",
        "kind": 2,
        "importPath": "commands.core.regex_cmd",
        "description": "commands.core.regex_cmd",
        "peekOfCode": "def cmd_flag_ml(c: context):\n    __set_regex_flag(re.MULTILINE, c.arg(1))\ndef cmd_flag_ic(c: context):\n    __set_regex_flag(re.IGNORECASE, c.arg(1))\n# cmd_flag_dt\n# cmd_flag_ml\n# cmd_flag_ic",
        "detail": "commands.core.regex_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_flag_ic",
        "kind": 2,
        "importPath": "commands.core.regex_cmd",
        "description": "commands.core.regex_cmd",
        "peekOfCode": "def cmd_flag_ic(c: context):\n    __set_regex_flag(re.IGNORECASE, c.arg(1))\n# cmd_flag_dt\n# cmd_flag_ml\n# cmd_flag_ic",
        "detail": "commands.core.regex_cmd",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "commands.core.regex_cmd",
        "description": "commands.core.regex_cmd",
        "peekOfCode": "__all__ = [\n    \"cmd_pattern\",\n    \"cmd_pattern_info\",\n    \"cmd_match\",\n    \"cmd_match_all\",\n    \"cmd_match_first\",\n    \"cmd_fullmatch\",\n    \"cmd_nonmatch\",\n    \"cmd_flag_dt\",\n    \"cmd_flag_ic\",",
        "detail": "commands.core.regex_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_capitalize",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_capitalize(c: context):\n    return set_return(c.arg(1).capitalize(), c.arg(3))\ndef cmd_upper(c: context):\n    return set_return(c.arg(1).upper(), c.arg(3))\ndef cmd_lower(c: context):\n    return set_return(c.arg(1).lower(), c.arg(3))\ndef cmd_title(c: context):\n    return set_return(' '.join(word.capitalize() for word in c.arg(1).split()), c.arg(3))\ndef cmd_slug(c: context):\n    from slugify import slugify",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_upper",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_upper(c: context):\n    return set_return(c.arg(1).upper(), c.arg(3))\ndef cmd_lower(c: context):\n    return set_return(c.arg(1).lower(), c.arg(3))\ndef cmd_title(c: context):\n    return set_return(' '.join(word.capitalize() for word in c.arg(1).split()), c.arg(3))\ndef cmd_slug(c: context):\n    from slugify import slugify\n    return set_return(slugify(c.arg(1)), c.arg(3))\ndef cmd_kebab(c: context):",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_lower",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_lower(c: context):\n    return set_return(c.arg(1).lower(), c.arg(3))\ndef cmd_title(c: context):\n    return set_return(' '.join(word.capitalize() for word in c.arg(1).split()), c.arg(3))\ndef cmd_slug(c: context):\n    from slugify import slugify\n    return set_return(slugify(c.arg(1)), c.arg(3))\ndef cmd_kebab(c: context):\n    return set_return(re.sub(r'[^a-zA-Z0-9]+', '-', c.arg(1).lower()).strip('-'), c.arg(3))\ndef cmd_camel(c:context):",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_title",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_title(c: context):\n    return set_return(' '.join(word.capitalize() for word in c.arg(1).split()), c.arg(3))\ndef cmd_slug(c: context):\n    from slugify import slugify\n    return set_return(slugify(c.arg(1)), c.arg(3))\ndef cmd_kebab(c: context):\n    return set_return(re.sub(r'[^a-zA-Z0-9]+', '-', c.arg(1).lower()).strip('-'), c.arg(3))\ndef cmd_camel(c:context):\n    return set_return(''.join([word.capitalize() for word in _getflat(c.arg(1)).split()]), c.arg(3))\ndef cmd_snake(c:context):",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_slug",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_slug(c: context):\n    from slugify import slugify\n    return set_return(slugify(c.arg(1)), c.arg(3))\ndef cmd_kebab(c: context):\n    return set_return(re.sub(r'[^a-zA-Z0-9]+', '-', c.arg(1).lower()).strip('-'), c.arg(3))\ndef cmd_camel(c:context):\n    return set_return(''.join([word.capitalize() for word in _getflat(c.arg(1)).split()]), c.arg(3))\ndef cmd_snake(c:context):\n    return set_return('_'.join(word.lower() for word in _getflat(c.arg(1)).split()), c.arg(3))\ndef cmd_macro(c:context):",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_kebab",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_kebab(c: context):\n    return set_return(re.sub(r'[^a-zA-Z0-9]+', '-', c.arg(1).lower()).strip('-'), c.arg(3))\ndef cmd_camel(c:context):\n    return set_return(''.join([word.capitalize() for word in _getflat(c.arg(1)).split()]), c.arg(3))\ndef cmd_snake(c:context):\n    return set_return('_'.join(word.lower() for word in _getflat(c.arg(1)).split()), c.arg(3))\ndef cmd_macro(c:context):\n    return set_return('_'.join(word.upper() for word in _getflat(c.arg(1)).split()), c.arg(3))\ndef cmd_flat(c:context):\n    return set_return(''.join(word.lower() for word in _getflat(c.arg(1)).split()), c.arg(3))",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_camel",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_camel(c:context):\n    return set_return(''.join([word.capitalize() for word in _getflat(c.arg(1)).split()]), c.arg(3))\ndef cmd_snake(c:context):\n    return set_return('_'.join(word.lower() for word in _getflat(c.arg(1)).split()), c.arg(3))\ndef cmd_macro(c:context):\n    return set_return('_'.join(word.upper() for word in _getflat(c.arg(1)).split()), c.arg(3))\ndef cmd_flat(c:context):\n    return set_return(''.join(word.lower() for word in _getflat(c.arg(1)).split()), c.arg(3))\ndef cmd_casefold(c:context):\n    return set_return(c.arg(1).casefold(), c.arg(3))",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_snake",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_snake(c:context):\n    return set_return('_'.join(word.lower() for word in _getflat(c.arg(1)).split()), c.arg(3))\ndef cmd_macro(c:context):\n    return set_return('_'.join(word.upper() for word in _getflat(c.arg(1)).split()), c.arg(3))\ndef cmd_flat(c:context):\n    return set_return(''.join(word.lower() for word in _getflat(c.arg(1)).split()), c.arg(3))\ndef cmd_casefold(c:context):\n    return set_return(c.arg(1).casefold(), c.arg(3))\ndef cmd_split(c: context):\n    if c.syntax in (1, 2):",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_macro",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_macro(c:context):\n    return set_return('_'.join(word.upper() for word in _getflat(c.arg(1)).split()), c.arg(3))\ndef cmd_flat(c:context):\n    return set_return(''.join(word.lower() for word in _getflat(c.arg(1)).split()), c.arg(3))\ndef cmd_casefold(c:context):\n    return set_return(c.arg(1).casefold(), c.arg(3))\ndef cmd_split(c: context):\n    if c.syntax in (1, 2):\n        return set_return(split_ext(c.arg(1), c.arg(3)), c.arg(5))\n    elif c.syntax in (3, 4):",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_flat",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_flat(c:context):\n    return set_return(''.join(word.lower() for word in _getflat(c.arg(1)).split()), c.arg(3))\ndef cmd_casefold(c:context):\n    return set_return(c.arg(1).casefold(), c.arg(3))\ndef cmd_split(c: context):\n    if c.syntax in (1, 2):\n        return set_return(split_ext(c.arg(1), c.arg(3)), c.arg(5))\n    elif c.syntax in (3, 4):\n        return set_return(c.arg(3).split(c.arg(1)), c.arg(5))\ndef cmd_swapcase(c:context):",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_casefold",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_casefold(c:context):\n    return set_return(c.arg(1).casefold(), c.arg(3))\ndef cmd_split(c: context):\n    if c.syntax in (1, 2):\n        return set_return(split_ext(c.arg(1), c.arg(3)), c.arg(5))\n    elif c.syntax in (3, 4):\n        return set_return(c.arg(3).split(c.arg(1)), c.arg(5))\ndef cmd_swapcase(c:context):\n    return set_return(c.arg(1).swapcase(), c.arg(3))\ndef cmd_trim(c:context):",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_split",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_split(c: context):\n    if c.syntax in (1, 2):\n        return set_return(split_ext(c.arg(1), c.arg(3)), c.arg(5))\n    elif c.syntax in (3, 4):\n        return set_return(c.arg(3).split(c.arg(1)), c.arg(5))\ndef cmd_swapcase(c:context):\n    return set_return(c.arg(1).swapcase(), c.arg(3))\ndef cmd_trim(c:context):\n    return set_return(c.arg(1).strip(), c.arg(3))\ndef cmd_trim_start(c:context):",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_swapcase",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_swapcase(c:context):\n    return set_return(c.arg(1).swapcase(), c.arg(3))\ndef cmd_trim(c:context):\n    return set_return(c.arg(1).strip(), c.arg(3))\ndef cmd_trim_start(c:context):\n    return set_return(c.arg(1).lstrip(), c.arg(3))\ndef cmd_trim_end(c:context):\n    return set_return(c.arg(1).rstrip(), c.arg(3))\ndef cmd_join(c:context):\n    return set_return(f'{c.arg(3)}'.join(c.arg(1)), c.arg(5))",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_trim",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_trim(c:context):\n    return set_return(c.arg(1).strip(), c.arg(3))\ndef cmd_trim_start(c:context):\n    return set_return(c.arg(1).lstrip(), c.arg(3))\ndef cmd_trim_end(c:context):\n    return set_return(c.arg(1).rstrip(), c.arg(3))\ndef cmd_join(c:context):\n    return set_return(f'{c.arg(3)}'.join(c.arg(1)), c.arg(5))\ndef cmd_substring(c:context):\n    if c.syntax in (1, 2):",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_trim_start",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_trim_start(c:context):\n    return set_return(c.arg(1).lstrip(), c.arg(3))\ndef cmd_trim_end(c:context):\n    return set_return(c.arg(1).rstrip(), c.arg(3))\ndef cmd_join(c:context):\n    return set_return(f'{c.arg(3)}'.join(c.arg(1)), c.arg(5))\ndef cmd_substring(c:context):\n    if c.syntax in (1, 2):\n        string = c.arg(1) [c.arg(3) - 1:c.arg(5)]\n        return set_return(string, c.arg(7))",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_trim_end",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_trim_end(c:context):\n    return set_return(c.arg(1).rstrip(), c.arg(3))\ndef cmd_join(c:context):\n    return set_return(f'{c.arg(3)}'.join(c.arg(1)), c.arg(5))\ndef cmd_substring(c:context):\n    if c.syntax in (1, 2):\n        string = c.arg(1) [c.arg(3) - 1:c.arg(5)]\n        return set_return(string, c.arg(7))\n    elif c.syntax in (3, 4):\n        return set_return(get_text_between(c.arg(3), c.arg(5), c.arg(1)), c.arg(7))",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_join",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_join(c:context):\n    return set_return(f'{c.arg(3)}'.join(c.arg(1)), c.arg(5))\ndef cmd_substring(c:context):\n    if c.syntax in (1, 2):\n        string = c.arg(1) [c.arg(3) - 1:c.arg(5)]\n        return set_return(string, c.arg(7))\n    elif c.syntax in (3, 4):\n        return set_return(get_text_between(c.arg(3), c.arg(5), c.arg(1)), c.arg(7))\ndef cmd_starts(c:context):\n    return set_return(c.arg(3).startswith(c.arg(1)), c.arg(5))",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_substring",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_substring(c:context):\n    if c.syntax in (1, 2):\n        string = c.arg(1) [c.arg(3) - 1:c.arg(5)]\n        return set_return(string, c.arg(7))\n    elif c.syntax in (3, 4):\n        return set_return(get_text_between(c.arg(3), c.arg(5), c.arg(1)), c.arg(7))\ndef cmd_starts(c:context):\n    return set_return(c.arg(3).startswith(c.arg(1)), c.arg(5))\ndef cmd_ends(c:context):\n    return set_return(c.arg(3).endswith(c.arg(1)), c.arg(5))",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_starts",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_starts(c:context):\n    return set_return(c.arg(3).startswith(c.arg(1)), c.arg(5))\ndef cmd_ends(c:context):\n    return set_return(c.arg(3).endswith(c.arg(1)), c.arg(5))\ndef cmd_truncate(c:context):\n    if c.syntax in (1,2):\n        slot = c.arg(5)\n        token = '...'\n    elif c.syntax in (3, 4):\n        slot = c.arg(7)",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_ends",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_ends(c:context):\n    return set_return(c.arg(3).endswith(c.arg(1)), c.arg(5))\ndef cmd_truncate(c:context):\n    if c.syntax in (1,2):\n        slot = c.arg(5)\n        token = '...'\n    elif c.syntax in (3, 4):\n        slot = c.arg(7)\n        token = c.arg(5)\n    _str = c.arg(1)",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_truncate",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_truncate(c:context):\n    if c.syntax in (1,2):\n        slot = c.arg(5)\n        token = '...'\n    elif c.syntax in (3, 4):\n        slot = c.arg(7)\n        token = c.arg(5)\n    _str = c.arg(1)\n    if len(_str) > c.arg(3): _str = _str[:c.arg(3)] + token\n    return set_return(_str, slot)",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_pad",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_pad(c:context):\n    return set_return(c.arg(1).center(c.arg(3), c.arg(5)), c.arg(7))\ndef cmd_padstr_l(c:context):\n    return set_return(pad_string(c.arg(1), c.arg(3), c.arg(5)), c.arg(7))\ndef cmd_padstr_r(c:context):\n    return set_return(pad_string(c.arg(1), c.arg(3), c.arg(5), 'r'), c.arg(7))\ndef cmd_escape(c:context):\n    #escaped = re.escape(c.arg(1))\n    # escaped = c.arg(1).encode('unicode_escape').decode('ascii')\n    import codecs",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_padstr_l",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_padstr_l(c:context):\n    return set_return(pad_string(c.arg(1), c.arg(3), c.arg(5)), c.arg(7))\ndef cmd_padstr_r(c:context):\n    return set_return(pad_string(c.arg(1), c.arg(3), c.arg(5), 'r'), c.arg(7))\ndef cmd_escape(c:context):\n    #escaped = re.escape(c.arg(1))\n    # escaped = c.arg(1).encode('unicode_escape').decode('ascii')\n    import codecs\n    escaped = c.arg(1)#.encode('unicode_escape').decode('ascii')\n    escaped, _ = codecs.unicode_escape_encode(c.arg(1), 'backslashreplace')",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_padstr_r",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_padstr_r(c:context):\n    return set_return(pad_string(c.arg(1), c.arg(3), c.arg(5), 'r'), c.arg(7))\ndef cmd_escape(c:context):\n    #escaped = re.escape(c.arg(1))\n    # escaped = c.arg(1).encode('unicode_escape').decode('ascii')\n    import codecs\n    escaped = c.arg(1)#.encode('unicode_escape').decode('ascii')\n    escaped, _ = codecs.unicode_escape_encode(c.arg(1), 'backslashreplace')\n    escaped = escaped.decode('unicode_escape')\n    return set_return(escaped, c.arg(3))",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_escape",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_escape(c:context):\n    #escaped = re.escape(c.arg(1))\n    # escaped = c.arg(1).encode('unicode_escape').decode('ascii')\n    import codecs\n    escaped = c.arg(1)#.encode('unicode_escape').decode('ascii')\n    escaped, _ = codecs.unicode_escape_encode(c.arg(1), 'backslashreplace')\n    escaped = escaped.decode('unicode_escape')\n    return set_return(escaped, c.arg(3))\ndef cmd_unescape(c:context):\n    # Fix",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_unescape",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_unescape(c:context):\n    # Fix\n    #import codecs\n    #unescaped = c.arg(1).encode().decode('unicode-escape')\n    #unescaped, _ = codecs.unicode_escape_decode(c.arg(1), 'backslashreplace')\n    unescaped = decode_text(c.arg(1))\n    return set_return(unescaped, c.arg(3))\ndef cmd_char(c:context):\n    return set_return(chr(c.arg(1)), c.arg(3))\ndef cmd_ord(c:context):",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_char",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_char(c:context):\n    return set_return(chr(c.arg(1)), c.arg(3))\ndef cmd_ord(c:context):\n    return set_return(ord(c.arg(1)[0]), c.arg(3))\ndef cmd_charat(c:context):\n    res = c.arg(3).__getitem__(c.arg(1) - 1)\n    return set_return(res, c.arg(5))\n# def cmd_format(c:context): return set_return(c.arg(1).format(*c.arg(3)), c.arg(5))\ndef cmd_format(c:context):\n    template = c.arg(1)",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_ord",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_ord(c:context):\n    return set_return(ord(c.arg(1)[0]), c.arg(3))\ndef cmd_charat(c:context):\n    res = c.arg(3).__getitem__(c.arg(1) - 1)\n    return set_return(res, c.arg(5))\n# def cmd_format(c:context): return set_return(c.arg(1).format(*c.arg(3)), c.arg(5))\ndef cmd_format(c:context):\n    template = c.arg(1)\n    values = c.arg(3)\n    def replace(match):",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_charat",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_charat(c:context):\n    res = c.arg(3).__getitem__(c.arg(1) - 1)\n    return set_return(res, c.arg(5))\n# def cmd_format(c:context): return set_return(c.arg(1).format(*c.arg(3)), c.arg(5))\ndef cmd_format(c:context):\n    template = c.arg(1)\n    values = c.arg(3)\n    def replace(match):\n        nulltype = 'NULL'\n        key = match.group(1)",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_format",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_format(c:context):\n    template = c.arg(1)\n    values = c.arg(3)\n    def replace(match):\n        nulltype = 'NULL'\n        key = match.group(1)\n        if isinstance(values, dict):\n            if key in values:\n                return str(values[key]) if values[key] is not None else nulltype\n            else:",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_replace",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_replace(c:context):\n    result = replace_text(c.arg(5), c.arg(1), c.arg(3), 1)\n    return set_return(result, c.arg(7))\ndef cmd_replace_all(c:context):\n    result = replace_text(c.arg(5), c.arg(1), c.arg(3), 0)\n    return set_return(result, c.arg(7))\ndef cmd_remove(c:context):\n    if c.syntax in (1, 2):\n        result = c.arg(3).replace(c.arg(1), '')\n        return set_return(result, c.arg(5))",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_replace_all",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_replace_all(c:context):\n    result = replace_text(c.arg(5), c.arg(1), c.arg(3), 0)\n    return set_return(result, c.arg(7))\ndef cmd_remove(c:context):\n    if c.syntax in (1, 2):\n        result = c.arg(3).replace(c.arg(1), '')\n        return set_return(result, c.arg(5))\n    elif c.syntax in (3, 4):\n        start = c.arg(2) - 1\n        end = c.arg(4)",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_remove",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_remove(c:context):\n    if c.syntax in (1, 2):\n        result = c.arg(3).replace(c.arg(1), '')\n        return set_return(result, c.arg(5))\n    elif c.syntax in (3, 4):\n        start = c.arg(2) - 1\n        end = c.arg(4)\n        result = c.arg(6)[:start] + c.arg(6)[end:]\n        return set_return(result, c.arg(8))\n    elif c.syntax == 5: del c.arg(3)[c.arg(1) - 1]",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_remove_acc",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_remove_acc(c:context):\n    import unicodedata\n    try:\n        normalized_text = unicodedata.normalize('NFD', c.arg(1))\n        # Filtrar y remover diacríticos (marcas de acento)\n        ascii_text = ''.join(char for char in normalized_text if unicodedata.category(char) != 'Mn')\n        return  set_return(ascii_text, c.arg(3))\n    except:\n        throw(e.UNSUPPORTED_CHARS)\ndef cmd_insert(c:context):",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_insert",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_insert(c:context):\n    # [STR, \"INTO|IN\", STR, AT, NUM],\n    position = c.arg(3)\n    src = c.arg(5)\n    new = c.arg(1)\n    if position < 0 or position > len(src):\n        throw(e.INDEX_ERROR)\n    if c.syntax in (1, 2):\n        result = src[:position] + new + src[position:]\n        return set_return(result, c.arg(7))",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_reverse",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_reverse(c: context):\n    src = c.arg(1)\n    if c.syntax in (1, 2): return set_return(''.join(reversed(src)), c.arg(3))\n    else:\n        src.reverse()\n        return src\ndef cmd_normalize(c:context):\n    import unicodedata\n    form = c.arg(3)\n    if form not in ('NFC', 'NFD', 'NFKC', 'NFKD'):",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_normalize",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_normalize(c:context):\n    import unicodedata\n    form = c.arg(3)\n    if form not in ('NFC', 'NFD', 'NFKC', 'NFKD'):\n        throw(e.INVALID_NORMALIZATION)\n    return set_return(unicodedata.normalize(form, c.arg(1)), c.arg(5))\ndef cmd_translit(c:context):\n    import unidecode\n    return set_return(unidecode.unidecode(c.arg(1)), c.arg(3))\n# Utils",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_translit",
        "kind": 2,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "def cmd_translit(c:context):\n    import unidecode\n    return set_return(unidecode.unidecode(c.arg(1)), c.arg(3))\n# Utils\ndef _getflat(text):\n    text = re.sub(r'[^a-zA-Z0-9]', ' ', text)\n    return text",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "commands.core.string_cmd",
        "description": "commands.core.string_cmd",
        "peekOfCode": "__all__ = [\n    \"cmd_capitalize\",\n    \"cmd_upper\",\n    \"cmd_lower\",\n    \"cmd_title\",\n    \"cmd_slug\",\n    \"cmd_kebab\",\n    \"cmd_camel\",\n    \"cmd_snake\",\n    \"cmd_macro\",",
        "detail": "commands.core.string_cmd",
        "documentation": {}
    },
    {
        "label": "ThreadJob",
        "kind": 6,
        "importPath": "commands.core.time_cmd",
        "description": "commands.core.time_cmd",
        "peekOfCode": "class ThreadJob(threading.Thread):\n    def __init__(self, callback, event, interval):\n        \"\"\"\n        Runs the callback function after interval seconds.\n        :param callback: Callback function to invoke.\n        :param event: External event for controlling the update operation.\n        :param interval: Time in seconds after which to fire the callback.\n        :type callback: function\n        :type event: threading.Event\n        :type interval: float",
        "detail": "commands.core.time_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_set_interval",
        "kind": 2,
        "importPath": "commands.core.time_cmd",
        "description": "commands.core.time_cmd",
        "peekOfCode": "def cmd_set_interval(c:context):\n    from ...execute import execute_lines, execute_loop\n    callback = execute_lines\n    args = c.childBlock\n    interval = c.arg(1)\n    job_callback = partial(callback, args)\n    event = threading.Event()\n    job = ThreadJob(job_callback, event, interval)\n    job.start()\n    this_id = get_id()",
        "detail": "commands.core.time_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_timeout",
        "kind": 2,
        "importPath": "commands.core.time_cmd",
        "description": "commands.core.time_cmd",
        "peekOfCode": "def cmd_timeout(c:context):\n    pass\ndef cmd_stop_interval(c:context):\n    pass\n# -- Utils ----\ndef _check_interval(map):\n    if isinstance(map, dict):\n        pass\n    return False",
        "detail": "commands.core.time_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_stop_interval",
        "kind": 2,
        "importPath": "commands.core.time_cmd",
        "description": "commands.core.time_cmd",
        "peekOfCode": "def cmd_stop_interval(c:context):\n    pass\n# -- Utils ----\ndef _check_interval(map):\n    if isinstance(map, dict):\n        pass\n    return False",
        "detail": "commands.core.time_cmd",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "commands.core.time_cmd",
        "description": "commands.core.time_cmd",
        "peekOfCode": "__all__ = [\"cmd_set_interval\", \"cmd_timeout\", \"cmd_stop_interval\"]\nclass ThreadJob(threading.Thread):\n    def __init__(self, callback, event, interval):\n        \"\"\"\n        Runs the callback function after interval seconds.\n        :param callback: Callback function to invoke.\n        :param event: External event for controlling the update operation.\n        :param interval: Time in seconds after which to fire the callback.\n        :type callback: function\n        :type event: threading.Event",
        "detail": "commands.core.time_cmd",
        "documentation": {}
    },
    {
        "label": "dataget",
        "kind": 2,
        "importPath": "commands.core.trans_cmd",
        "description": "commands.core.trans_cmd",
        "peekOfCode": "def dataget(value, default=None):\n    result = var_get(value, False)\n    return default if result is Return.NONE else result\ndef dataset(key, value):\n    var_set(key, value, True)\ndef cmd_translate(c:context):\n    global TRANSLATOR\n    if TRANSLATOR is None:\n        TRANSLATOR = Translator()\n    if c.syntax in (1, 2):",
        "detail": "commands.core.trans_cmd",
        "documentation": {}
    },
    {
        "label": "dataset",
        "kind": 2,
        "importPath": "commands.core.trans_cmd",
        "description": "commands.core.trans_cmd",
        "peekOfCode": "def dataset(key, value):\n    var_set(key, value, True)\ndef cmd_translate(c:context):\n    global TRANSLATOR\n    if TRANSLATOR is None:\n        TRANSLATOR = Translator()\n    if c.syntax in (1, 2):\n        text = c.arg(1)\n        src = dataget(SRC_VAR)\n        dest = dataget(DEST_VAR)",
        "detail": "commands.core.trans_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_translate",
        "kind": 2,
        "importPath": "commands.core.trans_cmd",
        "description": "commands.core.trans_cmd",
        "peekOfCode": "def cmd_translate(c:context):\n    global TRANSLATOR\n    if TRANSLATOR is None:\n        TRANSLATOR = Translator()\n    if c.syntax in (1, 2):\n        text = c.arg(1)\n        src = dataget(SRC_VAR)\n        dest = dataget(DEST_VAR)\n        attempts = dataget(ATT_VAR, 1)\n        if None in (src, dest):",
        "detail": "commands.core.trans_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_translatef",
        "kind": 2,
        "importPath": "commands.core.trans_cmd",
        "description": "commands.core.trans_cmd",
        "peekOfCode": "def cmd_translatef(c:context):\n    if TRANSLATOR is None:\n        TRANSLATOR = Translator()\n    text = c.arg(1)\n    src = dataget(SRC_VAR)\n    dest = dataget(DEST_VAR)\n    attempts = dataget(ATT_VAR, 1)\n    if None in (src, dest):\n        throw(e.MISSING_LANGUAGE_INIT)\n    for att_n in range(attempts):",
        "detail": "commands.core.trans_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_translate_from",
        "kind": 2,
        "importPath": "commands.core.trans_cmd",
        "description": "commands.core.trans_cmd",
        "peekOfCode": "def cmd_translate_from(c:context):\n    src_lng = check_lng(c.arg(1))\n    dataset(SRC_VAR, src_lng)\ndef cmd_translate_to(c:context):\n    dest_lng = check_lng(c.arg(1))\n    dataset(DEST_VAR, dest_lng)\ndef cmd_translate_attempts(c:context):\n    n = int(c.arg(1))\n    if n < 1: throw(e.INVALID_ATTEMPTS)\n    dataset(ATT_VAR, n)",
        "detail": "commands.core.trans_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_translate_to",
        "kind": 2,
        "importPath": "commands.core.trans_cmd",
        "description": "commands.core.trans_cmd",
        "peekOfCode": "def cmd_translate_to(c:context):\n    dest_lng = check_lng(c.arg(1))\n    dataset(DEST_VAR, dest_lng)\ndef cmd_translate_attempts(c:context):\n    n = int(c.arg(1))\n    if n < 1: throw(e.INVALID_ATTEMPTS)\n    dataset(ATT_VAR, n)\ndef cmd_translate_langs(c:context):\n    return set_return(Config.TLANGUAGES, c.arg(2))\ndef cmd_translate_codes(c:context):",
        "detail": "commands.core.trans_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_translate_attempts",
        "kind": 2,
        "importPath": "commands.core.trans_cmd",
        "description": "commands.core.trans_cmd",
        "peekOfCode": "def cmd_translate_attempts(c:context):\n    n = int(c.arg(1))\n    if n < 1: throw(e.INVALID_ATTEMPTS)\n    dataset(ATT_VAR, n)\ndef cmd_translate_langs(c:context):\n    return set_return(Config.TLANGUAGES, c.arg(2))\ndef cmd_translate_codes(c:context):\n    return set_return(Config.TLANGCODES, c.arg(2))\ndef check_lng(lang):\n    lang = lang.lower()",
        "detail": "commands.core.trans_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_translate_langs",
        "kind": 2,
        "importPath": "commands.core.trans_cmd",
        "description": "commands.core.trans_cmd",
        "peekOfCode": "def cmd_translate_langs(c:context):\n    return set_return(Config.TLANGUAGES, c.arg(2))\ndef cmd_translate_codes(c:context):\n    return set_return(Config.TLANGCODES, c.arg(2))\ndef check_lng(lang):\n    lang = lang.lower()\n    if not lang in Config.SUPPORTED_LANGS: throw(e.INVALID_LANGUAGE, [lang])\n    return lang",
        "detail": "commands.core.trans_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_translate_codes",
        "kind": 2,
        "importPath": "commands.core.trans_cmd",
        "description": "commands.core.trans_cmd",
        "peekOfCode": "def cmd_translate_codes(c:context):\n    return set_return(Config.TLANGCODES, c.arg(2))\ndef check_lng(lang):\n    lang = lang.lower()\n    if not lang in Config.SUPPORTED_LANGS: throw(e.INVALID_LANGUAGE, [lang])\n    return lang",
        "detail": "commands.core.trans_cmd",
        "documentation": {}
    },
    {
        "label": "check_lng",
        "kind": 2,
        "importPath": "commands.core.trans_cmd",
        "description": "commands.core.trans_cmd",
        "peekOfCode": "def check_lng(lang):\n    lang = lang.lower()\n    if not lang in Config.SUPPORTED_LANGS: throw(e.INVALID_LANGUAGE, [lang])\n    return lang",
        "detail": "commands.core.trans_cmd",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "commands.core.trans_cmd",
        "description": "commands.core.trans_cmd",
        "peekOfCode": "__all__ = [\n    \"cmd_translate\",\n    \"cmd_translatef\",\n    \"cmd_translate_from\",\n    \"cmd_translate_to\",\n    \"cmd_translate_attempts\",\n    \"cmd_translate_langs\",\n    \"cmd_translate_codes\",\n]\nTRANSLATOR = None",
        "detail": "commands.core.trans_cmd",
        "documentation": {}
    },
    {
        "label": "TRANSLATOR",
        "kind": 5,
        "importPath": "commands.core.trans_cmd",
        "description": "commands.core.trans_cmd",
        "peekOfCode": "TRANSLATOR = None\nSRC_VAR = '$_TRANSLATE_SRC_LANG'\nDEST_VAR = '$_TRANSLATE_DEST_LANG'\nATT_VAR = '$_TRANSLATE_ATTEMPTS'\ndef dataget(value, default=None):\n    result = var_get(value, False)\n    return default if result is Return.NONE else result\ndef dataset(key, value):\n    var_set(key, value, True)\ndef cmd_translate(c:context):",
        "detail": "commands.core.trans_cmd",
        "documentation": {}
    },
    {
        "label": "SRC_VAR",
        "kind": 5,
        "importPath": "commands.core.trans_cmd",
        "description": "commands.core.trans_cmd",
        "peekOfCode": "SRC_VAR = '$_TRANSLATE_SRC_LANG'\nDEST_VAR = '$_TRANSLATE_DEST_LANG'\nATT_VAR = '$_TRANSLATE_ATTEMPTS'\ndef dataget(value, default=None):\n    result = var_get(value, False)\n    return default if result is Return.NONE else result\ndef dataset(key, value):\n    var_set(key, value, True)\ndef cmd_translate(c:context):\n    global TRANSLATOR",
        "detail": "commands.core.trans_cmd",
        "documentation": {}
    },
    {
        "label": "DEST_VAR",
        "kind": 5,
        "importPath": "commands.core.trans_cmd",
        "description": "commands.core.trans_cmd",
        "peekOfCode": "DEST_VAR = '$_TRANSLATE_DEST_LANG'\nATT_VAR = '$_TRANSLATE_ATTEMPTS'\ndef dataget(value, default=None):\n    result = var_get(value, False)\n    return default if result is Return.NONE else result\ndef dataset(key, value):\n    var_set(key, value, True)\ndef cmd_translate(c:context):\n    global TRANSLATOR\n    if TRANSLATOR is None:",
        "detail": "commands.core.trans_cmd",
        "documentation": {}
    },
    {
        "label": "ATT_VAR",
        "kind": 5,
        "importPath": "commands.core.trans_cmd",
        "description": "commands.core.trans_cmd",
        "peekOfCode": "ATT_VAR = '$_TRANSLATE_ATTEMPTS'\ndef dataget(value, default=None):\n    result = var_get(value, False)\n    return default if result is Return.NONE else result\ndef dataset(key, value):\n    var_set(key, value, True)\ndef cmd_translate(c:context):\n    global TRANSLATOR\n    if TRANSLATOR is None:\n        TRANSLATOR = Translator()",
        "detail": "commands.core.trans_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_set",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_set(c: context):\n    if c.syntax in (1, 2):\n        var_name = c.arg(1).strip('$')\n        value = c.arg(3)\n        var_set(var_name, value)\n    elif c.syntax == 3:\n        vars = c.arg(1)\n        pack = c.arg(3)\n        if len(vars) > len(pack):\n            throw(e.INCOMPLETE_VALUE_UNPACKING, [len(vars), len(pack)])",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_gset",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_gset(c: context):\n    if c.syntax in (1, 2):\n        var_name = c.arg(1)\n        value = c.arg(3)\n        var_set(var_name, value, set_global=True)\n    elif c.syntax == 3:\n        vars = c.arg(1)\n        pack = c.arg(3)\n        validate_elems(pack, len(vars))\n        for i, var in enumerate(vars):",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_unset",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_unset(c: context):\n    targ = c.arg(1)\n    if isinstance(targ, list):\n        for x in targ:\n            var_unset(x)\n    else:\n        var_unset(targ)\ndef cmd_varset(c: context):\n    var_org = c.arg(1)\n    var = var_org",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_varset",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_varset(c: context):\n    var_org = c.arg(1)\n    var = var_org\n    if var[0] == '@':\n        throw(e.PROTECTED_ENVARS)\n    if var[0] != '$':\n        var = \"$\" + var\n    if not CompiledPatterns.VARIABLE.fullmatch(var):\n        throw(e.INVALID_TS_VARNAME, [var_org])\n    value = c.arg(3)",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_varget",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_varget(c:context):\n    var = c.arg(1)\n    if var[0] not in ('$', '@'): var = \"$\" + var\n    return set_return(var_get(var), c.arg(3))\ndef cmd_varexists(c: context):\n    var = c.arg(1)\n    if var[0] not in ('$', '@'): var = \"$\" + var\n    return set_return(var_exists(var), c.arg(3))\ndef cmd_rassign(c:context):\n    if not rt.on_definition:",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_varexists",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_varexists(c: context):\n    var = c.arg(1)\n    if var[0] not in ('$', '@'): var = \"$\" + var\n    return set_return(var_exists(var), c.arg(3))\ndef cmd_rassign(c:context):\n    if not rt.on_definition:\n        throw(e.INVALID_RASSIGN)\n    value = c.arg(1)\n    var = c.arg(3)\n    if isinstance(var, str):",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_rassign",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_rassign(c:context):\n    if not rt.on_definition:\n        throw(e.INVALID_RASSIGN)\n    value = c.arg(1)\n    var = c.arg(3)\n    if isinstance(var, str):\n        if var[0] == '@': throw(e.PROTECTED_ENVARS)\n        if var[0] != '$': var = \"$\" + var\n        if not CompiledPatterns.VARIABLE.fullmatch(var):\n            throw(e.INVALID_TS_VARNAME, [var])",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_varunset",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_varunset(c: context):\n    var = c.arg(1)\n    if var[0] not in ('$', '@'): var = \"$\" + var\n    var_unset(var)\ndef cmd_append(c:context):\n    if c.syntax == 1:\n        c.arg(3).append(c.arg(1))\ndef cmd_get(c:context):\n    if c.syntax in (1, 2):\n        key = c.arg(1)",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_append",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_append(c:context):\n    if c.syntax == 1:\n        c.arg(3).append(c.arg(1))\ndef cmd_get(c:context):\n    if c.syntax in (1, 2):\n        key = c.arg(1)\n        data = c.arg(3)\n        if isinstance(data, dict):\n            return set_return(data.get(key, None), c.arg(5))\n        elif isinstance(data, list):",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_get",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_get(c:context):\n    if c.syntax in (1, 2):\n        key = c.arg(1)\n        data = c.arg(3)\n        if isinstance(data, dict):\n            return set_return(data.get(key, None), c.arg(5))\n        elif isinstance(data, list):\n            if not isinstance(key, int):\n                throwCustom(\"Only indexs allowed\")\n            return set_return(get_element(data, key - 1, None), c.arg(5))",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_pick",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_pick(c:context):\n    if c.syntax in (1, 2):\n        return set_return(c.arg(1) if c.arg(1) else c.arg(3), c.arg(5))\n    if c.syntax in (3, 4):\n        for value in c.arg(1):\n            if value:\n                return set_return(value, c.arg(3))\n        return set_return(None, c.arg(3))\ndef cmd_clear(c:context):\n    value = c.arg(1)",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_clear",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_clear(c:context):\n    value = c.arg(1)\n    if isinstance(value, (list, dict)):\n        value.clear()\n        return value\n    elif CompiledPatterns.VARIABLE.fullmatch(c.token(1)):\n        if isinstance(value, str): value = \"\"\n        elif isinstance(value, (int, float)): value = 0\n        elif isinstance(value, bool): value = False\n        else:",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_copy",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_copy(c:context):\n    import copy\n    res = copy.copy(c.arg(1))\n    return set_return(res, c.arg(3))\n    #var_set(c.arg(3), copy.copy(c.arg(1)))\ndef cmd_clone(c:context):\n    import copy\n    res = copy.deepcopy(c.arg(1))\n    return set_return(res, c.arg(3))\n# Fix",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_clone",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_clone(c:context):\n    import copy\n    res = copy.deepcopy(c.arg(1))\n    return set_return(res, c.arg(3))\n# Fix\ndef cmd_cmdexists(c:context):\n    return set_return(c.arg(1) in Config.COMMANDS, c.arg(3))\n# Type\ndef cmd_type(c: context):\n    return set_return(type_name(c.arg(1)), c.arg(3))",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_cmdexists",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_cmdexists(c:context):\n    return set_return(c.arg(1) in Config.COMMANDS, c.arg(3))\n# Type\ndef cmd_type(c: context):\n    return set_return(type_name(c.arg(1)), c.arg(3))\ndef cmd_tostr(c: context):\n    data = to_string(c.arg(1))\n    return set_return(str(data), c.arg(3))\ndef cmd_toint(c:context):\n    data = c.arg(1)",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_type",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_type(c: context):\n    return set_return(type_name(c.arg(1)), c.arg(3))\ndef cmd_tostr(c: context):\n    data = to_string(c.arg(1))\n    return set_return(str(data), c.arg(3))\ndef cmd_toint(c:context):\n    data = c.arg(1)\n    if not isinstance(data, (int, float, str)):\n        throw(e.INVALID_CONVERTION, [type_name(data), DataType.NUMBER]) \n    try:",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_tostr",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_tostr(c: context):\n    data = to_string(c.arg(1))\n    return set_return(str(data), c.arg(3))\ndef cmd_toint(c:context):\n    data = c.arg(1)\n    if not isinstance(data, (int, float, str)):\n        throw(e.INVALID_CONVERTION, [type_name(data), DataType.NUMBER]) \n    try:\n        n = format_num(data)\n        if math.isinf(n):",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_toint",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_toint(c:context):\n    data = c.arg(1)\n    if not isinstance(data, (int, float, str)):\n        throw(e.INVALID_CONVERTION, [type_name(data), DataType.NUMBER]) \n    try:\n        n = format_num(data)\n        if math.isinf(n):\n            throw(e.UNSUPPORTED_CONVERTION, [KW.INFINITY, DataType.NUMBER])\n        if math.isnan(n):\n            throw(e.UNSUPPORTED_CONVERTION, [KW.NAN, DataType.NUMBER])",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_tofloat",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_tofloat(c: context):\n    data = c.arg(1)\n    if not isinstance(data, (int, float, str)):\n        throw(e.INVALID_CONVERTION, [type_name(data), Label.FLOATN])\n    try:\n        result = format_num(data)\n        return set_return(float(result), c.arg(3)) \n    except ValueError:\n        throw(e.UNSUPPORTED_CONVERTION, [data, Label.FLOATN])\ndef cmd_tobool(c: context):",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_tobool",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_tobool(c: context):\n    try:\n        value = bool(c.arg(1))\n    except:\n        value = False\n    return set_return(value, c.arg(3))\ndef cmd_toarray(c:context):\n    data = c.arg(1)\n    if isinstance(data, (str, list, dict)):\n        result = list(data)",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_toarray",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_toarray(c:context):\n    data = c.arg(1)\n    if isinstance(data, (str, list, dict)):\n        result = list(data)\n        return set_return(result, c.arg(3))\n    else:\n        throw(e.INVALID_CONVERTION, [type_name(data), DataType.ARRAY])\ndef cmd_tomap(c:context):\n    data = c.arg(1)\n    result = {}",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_tomap",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_tomap(c:context):\n    data = c.arg(1)\n    result = {}\n    if isinstance(data, list):\n        for pair in data:\n            if len(pair) == 2:\n                key, value = pair\n                result[key] = value\n            else:\n                throwCustom(\"Cada par debe contener exactamente dos elementos.\")",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "cmd_length",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def cmd_length(c:context):\n    if not isinstance(c.arg(1), (str, list, dict)):\n        throw(e.UNAVAILABLE_LENGTH, [type_name(c.arg(1))])\n    return set_return(len(c.arg(1)), c.arg(3))\n# case 'SET': var_set(arg(1), arg(3))\n# Utils\ndef format_num(val):\n    if isinstance(val, str):\n        val = val.strip()  # Remove leading/trailing whitespace\n        if val == KW.INFINITY or val == f'-{KW.INFINITY}':",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "format_num",
        "kind": 2,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "def format_num(val):\n    if isinstance(val, str):\n        val = val.strip()  # Remove leading/trailing whitespace\n        if val == KW.INFINITY or val == f'-{KW.INFINITY}':\n            return math.inf\n        if val == KW.NAN or val == f'-{KW.NAN}':\n            return math.nan\n        # Avoid Python-specific format\n        if '_' in val or val.lower() in ['inf', '-inf', 'nan', '-nan', 'infinity', '-infinity']:\n            raise ValueError()",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "commands.core.vars_cmd",
        "description": "commands.core.vars_cmd",
        "peekOfCode": "__all__ = [\n    \"cmd_set\",\n    \"cmd_gset\",\n    \"cmd_unset\",\n    \"cmd_append\",\n    \"cmd_get\",\n    \"cmd_pick\",\n    \"cmd_clear\",\n    \"cmd_copy\",\n    \"cmd_clone\",",
        "detail": "commands.core.vars_cmd",
        "documentation": {}
    },
    {
        "label": "CommandContext",
        "kind": 6,
        "importPath": "commands.context",
        "description": "commands.context",
        "peekOfCode": "class CommandContext:\n    def __init__(self, cmd, arg, token, params, tokens, childBlock, syntax, raw):\n        self.cmd = cmd\n        self.arg = arg\n        self.token = token\n        self.params = params\n        self.tokens = tokens\n        self.childBlock = childBlock\n        self.syntax = int(syntax)\n        self.raw = raw",
        "detail": "commands.context",
        "documentation": {}
    },
    {
        "label": "set_return",
        "kind": 2,
        "importPath": "commands.helpers",
        "description": "commands.helpers",
        "peekOfCode": "def set_return(value, varname): # This function can return something or save the value in a variable\n    #if isinstance(value, tuple): value = list(value)\n    if varname:\n        var_set(varname, value)\n        return None\n    else:\n        return value\ndef split_ext(string:str, token:str = '', times = -1):\n    if token == '':\n        return list(string)",
        "detail": "commands.helpers",
        "documentation": {}
    },
    {
        "label": "split_ext",
        "kind": 2,
        "importPath": "commands.helpers",
        "description": "commands.helpers",
        "peekOfCode": "def split_ext(string:str, token:str = '', times = -1):\n    if token == '':\n        return list(string)\n    else:\n        return string.split(token)\ndef build_params(syntax, token:str):\n    if isinstance(syntax, str):\n        syntax = syntax.split(' ')\n    def each_param(param, nested = False):\n        if param in Config.VALID_PARAMS:",
        "detail": "commands.helpers",
        "documentation": {}
    },
    {
        "label": "build_params",
        "kind": 2,
        "importPath": "commands.helpers",
        "description": "commands.helpers",
        "peekOfCode": "def build_params(syntax, token:str):\n    if isinstance(syntax, str):\n        syntax = syntax.split(' ')\n    def each_param(param, nested = False):\n        if param in Config.VALID_PARAMS:\n            return param\n        elif type_name(param) == DataType.CONNECTOR:\n            return param[0]\n        elif isinstance(param, list):\n            if not nested:",
        "detail": "commands.helpers",
        "documentation": {}
    },
    {
        "label": "get_text_between",
        "kind": 2,
        "importPath": "commands.helpers",
        "description": "commands.helpers",
        "peekOfCode": "def get_text_between(start_char, end_char, text):\n    start = text.find(start_char)\n    if start == -1:\n        return None\n    start += len(start_char)\n    end = text.find(end_char, start)\n    if end == -1:\n        return None\n    return text[start:end]\ndef pad_string(string, n, fill=' ', direction='l'):",
        "detail": "commands.helpers",
        "documentation": {}
    },
    {
        "label": "pad_string",
        "kind": 2,
        "importPath": "commands.helpers",
        "description": "commands.helpers",
        "peekOfCode": "def pad_string(string, n, fill=' ', direction='l'):\n    if len(fill) != 1:\n        raise ValueError(\"El parámetro 'fill' debe ser un solo carácter.\")\n    if len(string) >= n: return string\n    padding = fill * (n - len(string))\n    return padding + string if direction == 'l' else string + padding\ndef replace_text(base:str, old, new:str, times = 0):\n    if isinstance(old, re.Pattern): return old.sub(new, base, times)\n    elif isinstance(old, str): return base.replace(old, new, times if times > 0 else -1)\ndef find_in(value, i, times = 1):",
        "detail": "commands.helpers",
        "documentation": {}
    },
    {
        "label": "replace_text",
        "kind": 2,
        "importPath": "commands.helpers",
        "description": "commands.helpers",
        "peekOfCode": "def replace_text(base:str, old, new:str, times = 0):\n    if isinstance(old, re.Pattern): return old.sub(new, base, times)\n    elif isinstance(old, str): return base.replace(old, new, times if times > 0 else -1)\ndef find_in(value, i, times = 1):\n    if isinstance(i, list):\n        try: return i.index(value) + 1\n        except ValueError: return 0\n    elif isinstance(i, str):\n        if isinstance(value, str):\n            return i.find(value) + 1",
        "detail": "commands.helpers",
        "documentation": {}
    },
    {
        "label": "find_in",
        "kind": 2,
        "importPath": "commands.helpers",
        "description": "commands.helpers",
        "peekOfCode": "def find_in(value, i, times = 1):\n    if isinstance(i, list):\n        try: return i.index(value) + 1\n        except ValueError: return 0\n    elif isinstance(i, str):\n        if isinstance(value, str):\n            return i.find(value) + 1\n        elif isinstance(value, re.Pattern):\n            n = re.search(value, i)\n            return n.start() + 1 if n is not None else 0",
        "detail": "commands.helpers",
        "documentation": {}
    },
    {
        "label": "count_in",
        "kind": 2,
        "importPath": "commands.helpers",
        "description": "commands.helpers",
        "peekOfCode": "def count_in(value, i):\n    if isinstance(i, list): return i.count(value)\n    elif isinstance(i, str):\n        if isinstance(value, str): return i.count(value)\n        elif isinstance(value, re.Pattern): return len(value.findall(i))\ndef flatten(data):\n    if isinstance(data, (list, tuple, set, range)):\n        for sub in data:\n            yield from flatten(sub)\n    else:",
        "detail": "commands.helpers",
        "documentation": {}
    },
    {
        "label": "flatten",
        "kind": 2,
        "importPath": "commands.helpers",
        "description": "commands.helpers",
        "peekOfCode": "def flatten(data):\n    if isinstance(data, (list, tuple, set, range)):\n        for sub in data:\n            yield from flatten(sub)\n    else:\n        yield data\ndef validate_type(param, data, _type):\n    if not isinstance(data, _type):\n        throw(e.INVALID_PARAM_TYPE, [param, type_name(_type), type_name(data)])\n    return True",
        "detail": "commands.helpers",
        "documentation": {}
    },
    {
        "label": "validate_type",
        "kind": 2,
        "importPath": "commands.helpers",
        "description": "commands.helpers",
        "peekOfCode": "def validate_type(param, data, _type):\n    if not isinstance(data, _type):\n        throw(e.INVALID_PARAM_TYPE, [param, type_name(_type), type_name(data)])\n    return True\ndef validate_n_gt(param, label, n, gt):\n    if not n > gt:\n        throw(e.INVALID_PARAM_GT, [label, gt])\n    return True\ndef get_id():\n    return str(uuid.uuid4())",
        "detail": "commands.helpers",
        "documentation": {}
    },
    {
        "label": "validate_n_gt",
        "kind": 2,
        "importPath": "commands.helpers",
        "description": "commands.helpers",
        "peekOfCode": "def validate_n_gt(param, label, n, gt):\n    if not n > gt:\n        throw(e.INVALID_PARAM_GT, [label, gt])\n    return True\ndef get_id():\n    return str(uuid.uuid4())\ndef validate_elems(arr, n):\n    length = len(arr)\n    if length == 0 or n == 0:\n        throw(e.EMPTY_ARRAY)",
        "detail": "commands.helpers",
        "documentation": {}
    },
    {
        "label": "get_id",
        "kind": 2,
        "importPath": "commands.helpers",
        "description": "commands.helpers",
        "peekOfCode": "def get_id():\n    return str(uuid.uuid4())\ndef validate_elems(arr, n):\n    length = len(arr)\n    if length == 0 or n == 0:\n        throw(e.EMPTY_ARRAY)\n    elif length > n:\n        throw(e.EXCESSIVE_VALUE_UNPACKING, [n, length])\n    elif length < n:\n        throw(e.INCOMPLETE_VALUE_UNPACKING, [n, length])",
        "detail": "commands.helpers",
        "documentation": {}
    },
    {
        "label": "validate_elems",
        "kind": 2,
        "importPath": "commands.helpers",
        "description": "commands.helpers",
        "peekOfCode": "def validate_elems(arr, n):\n    length = len(arr)\n    if length == 0 or n == 0:\n        throw(e.EMPTY_ARRAY)\n    elif length > n:\n        throw(e.EXCESSIVE_VALUE_UNPACKING, [n, length])\n    elif length < n:\n        throw(e.INCOMPLETE_VALUE_UNPACKING, [n, length])",
        "detail": "commands.helpers",
        "documentation": {}
    },
    {
        "label": "run_command",
        "kind": 2,
        "importPath": "commands.run_command copy",
        "description": "commands.run_command copy",
        "peekOfCode": "def run_command(cmd: str, params:list, tokens:list, childBlock:dict = False, syntax = -1, fromModule:dict={}):\n    from ..execute import execute_lines, execute_line, execute_definition\n    #print(\"Command\", cmd, params, tokens, childBlock, syntax)\n    syntax = int(syntax) + 1\n    context = CommandContext(cmd, (\n        lambda x, y=None: get_element(params, x - 1, y)),\n        lambda x: get_element(tokens, x - 1, None),\n        params,\n        tokens,\n        childBlock,",
        "detail": "commands.run_command copy",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "commands.run_command copy",
        "description": "commands.run_command copy",
        "peekOfCode": "__all__ = ['run_command']\n#@hcache()\ndef run_command(cmd: str, params:list, tokens:list, childBlock:dict = False, syntax = -1, fromModule:dict={}):\n    from ..execute import execute_lines, execute_line, execute_definition\n    #print(\"Command\", cmd, params, tokens, childBlock, syntax)\n    syntax = int(syntax) + 1\n    context = CommandContext(cmd, (\n        lambda x, y=None: get_element(params, x - 1, y)),\n        lambda x: get_element(tokens, x - 1, None),\n        params,",
        "detail": "commands.run_command copy",
        "documentation": {}
    },
    {
        "label": "run_command",
        "kind": 2,
        "importPath": "commands.run_command",
        "description": "commands.run_command",
        "peekOfCode": "def run_command(cmd: str, params: list, tokens: list, childBlock: dict = False, syntax = -1, fromModule = {}):\n    from ..execute import execute_definition\n    syntax = int(syntax) + 1\n    context = CommandContext(cmd, (\n        lambda x, y=None: get_element(params, x - 1, y)),\n        lambda x: get_element(tokens, x - 1, None),\n        params,\n        tokens,\n        childBlock,\n        syntax,",
        "detail": "commands.run_command",
        "documentation": {}
    },
    {
        "label": "run_custom_command",
        "kind": 2,
        "importPath": "commands.run_command",
        "description": "commands.run_command",
        "peekOfCode": "def run_custom_command(cmd):\n    from ..execute import execute_definition\n    rassign.push([])\n    result = execute_definition(rt.CUSTOM_COMMANDS[cmd])\n    rassign_root = rt.rassign_context.get(rt.running_context)\n    if rt.rassign_instances:\n        for var in rt.rassign_instances:\n            var_set(var[0], var[1])\n        rt.rassign_instances = rassign.pop() if not rassign.is_empty() else []\n    elif rassign_root:",
        "detail": "commands.run_command",
        "documentation": {}
    },
    {
        "label": "run_module_command",
        "kind": 2,
        "importPath": "commands.run_command",
        "description": "commands.run_command",
        "peekOfCode": "def run_module_command(cmd):\n    from ..execute import execute_definition\n    id = rt.GLOBAL_COMMANDS[cmd][0]\n    cmd_block = module_get_prop('CUSTOM_COMMANDS', cmd)\n    module_file = rt.MODULES.get(id, {}).get('file', '')\n    # DISABLE LOG\n    # - Disable command, line, context loggin\n    show_logs_stack.push(rt.LogActions)\n    rt.LogActions = False\n    # BACKUP CONTEXT",
        "detail": "commands.run_command",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "commands.run_command",
        "description": "commands.run_command",
        "peekOfCode": "__all__ = ['run_command']\nruntime_stack = Stack()\nshow_logs_stack = Stack()\nrassign = Stack()\nmodule_stack = Stack()\ndef run_command(cmd: str, params: list, tokens: list, childBlock: dict = False, syntax = -1, fromModule = {}):\n    from ..execute import execute_definition\n    syntax = int(syntax) + 1\n    context = CommandContext(cmd, (\n        lambda x, y=None: get_element(params, x - 1, y)),",
        "detail": "commands.run_command",
        "documentation": {}
    },
    {
        "label": "runtime_stack",
        "kind": 5,
        "importPath": "commands.run_command",
        "description": "commands.run_command",
        "peekOfCode": "runtime_stack = Stack()\nshow_logs_stack = Stack()\nrassign = Stack()\nmodule_stack = Stack()\ndef run_command(cmd: str, params: list, tokens: list, childBlock: dict = False, syntax = -1, fromModule = {}):\n    from ..execute import execute_definition\n    syntax = int(syntax) + 1\n    context = CommandContext(cmd, (\n        lambda x, y=None: get_element(params, x - 1, y)),\n        lambda x: get_element(tokens, x - 1, None),",
        "detail": "commands.run_command",
        "documentation": {}
    },
    {
        "label": "show_logs_stack",
        "kind": 5,
        "importPath": "commands.run_command",
        "description": "commands.run_command",
        "peekOfCode": "show_logs_stack = Stack()\nrassign = Stack()\nmodule_stack = Stack()\ndef run_command(cmd: str, params: list, tokens: list, childBlock: dict = False, syntax = -1, fromModule = {}):\n    from ..execute import execute_definition\n    syntax = int(syntax) + 1\n    context = CommandContext(cmd, (\n        lambda x, y=None: get_element(params, x - 1, y)),\n        lambda x: get_element(tokens, x - 1, None),\n        params,",
        "detail": "commands.run_command",
        "documentation": {}
    },
    {
        "label": "rassign",
        "kind": 5,
        "importPath": "commands.run_command",
        "description": "commands.run_command",
        "peekOfCode": "rassign = Stack()\nmodule_stack = Stack()\ndef run_command(cmd: str, params: list, tokens: list, childBlock: dict = False, syntax = -1, fromModule = {}):\n    from ..execute import execute_definition\n    syntax = int(syntax) + 1\n    context = CommandContext(cmd, (\n        lambda x, y=None: get_element(params, x - 1, y)),\n        lambda x: get_element(tokens, x - 1, None),\n        params,\n        tokens,",
        "detail": "commands.run_command",
        "documentation": {}
    },
    {
        "label": "module_stack",
        "kind": 5,
        "importPath": "commands.run_command",
        "description": "commands.run_command",
        "peekOfCode": "module_stack = Stack()\ndef run_command(cmd: str, params: list, tokens: list, childBlock: dict = False, syntax = -1, fromModule = {}):\n    from ..execute import execute_definition\n    syntax = int(syntax) + 1\n    context = CommandContext(cmd, (\n        lambda x, y=None: get_element(params, x - 1, y)),\n        lambda x: get_element(tokens, x - 1, None),\n        params,\n        tokens,\n        childBlock,",
        "detail": "commands.run_command",
        "documentation": {}
    },
    {
        "label": "Command",
        "kind": 6,
        "importPath": "config.config",
        "description": "config.config",
        "peekOfCode": "class Command:\n    ON = \"ON\"\n    INPUT = \"INPUT\"\n    IF = \"WHEN\"\n    ELIF = \"ORWHEN\"\n    ELSE = \"ELSE\"\n    OR = \"OR\"\n    AND = \"AND\"\n    WHILE = \"WHILE\"\n    DEFINE = \"DEFINE\"",
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Event",
        "kind": 6,
        "importPath": "config.config",
        "description": "config.config",
        "peekOfCode": "class Event:\n    GLOBAL = \"GLOBAL\"\n    START = \"START\"\n    END = \"END\"\n    EACH_LINE = \"EACH_LINE\"\n    ODD_LINES = \"ODD_LINES\"\n    EVEN_LINES = \"EVEN_LINES\"\n    EMPTY_LINES = \"EMPTY_LINES\"\n    CONTENT_LINES = \"CONTENT_LINES\"\n# Envars",
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Envar",
        "kind": 6,
        "importPath": "config.config",
        "description": "config.config",
        "peekOfCode": "class Envar:\n    CONTENT = \"CONTENT\"\n    LINE = \"LINE\"\n    LINES = \"LINES\"\n    INDEX = \"LINE_INDEX\"\n    WORDS = \"WORDS\"\n    CHARS = \"CHARS\"\n    KEY = \"KEY\"\n    KINDEX = \"INDEX\"\n    PARAMS = \"PARAMS\"",
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "KW",
        "kind": 6,
        "importPath": "config.config",
        "description": "config.config",
        "peekOfCode": "class KW:\n    TRUE = \"TRUE\"\n    FALSE = \"FALSE\"\n    EMPTY = \"EMPTY\"\n    NULL = \"NULL\"\n    STRING = \"STRING\"\n    NUMBER = \"NUMBER\"\n    MAP = \"MAP\"\n    ARRAY = \"ARRAY\"\n    BOOL = \"BOOL\"",
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "DataType",
        "kind": 6,
        "importPath": "config.config",
        "description": "config.config",
        "peekOfCode": "class DataType:\n    STRING = KW.STRING\n    NUMBER = KW.NUMBER\n    BOOL = KW.BOOL\n    ARRAY = KW.ARRAY\n    MAP = KW.MAP\n    NULL = KW.NULL\n    UNKNOWN = \"UNKNOWN\"\n    ANY = \"ANY\"\n    ALL = \"ALL\"",
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Label",
        "kind": 6,
        "importPath": "config.config",
        "description": "config.config",
        "peekOfCode": "class Label:\n    SIZE = \"Size\"\n    UNPRINTABLE = \"<< UNPRINTABLE >>\"\n    FLOAT = \"FLOAT\"\n    FLOATN = \"float NUMBER\"\nclass Config:\n    # CONSTANTS ---------------------------\n    # Signs\n    CHAR_DDSL = \"\\u2BF2\"\n    CHAR_DOLLAR = \"\\u2104\"",
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "config.config",
        "description": "config.config",
        "peekOfCode": "class Config:\n    # CONSTANTS ---------------------------\n    # Signs\n    CHAR_DDSL = \"\\u2BF2\"\n    CHAR_DOLLAR = \"\\u2104\"\n    CHAR_AT = \"\\u200B\"\n    CHAR_PIPE = \"\\u0091\"\n    CHAR_DQUOTE = \"\\u2B1A\"\n    CHAR_SQUOTE = \"\\u2B12\"\n    CHAR_HASH = \"\\u2603\"",
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Return",
        "kind": 6,
        "importPath": "config.config",
        "description": "config.config",
        "peekOfCode": "class Return:\n    BREAK = (Command.BREAK, 1010)\n    CONTINUE = (Command.CONTINUE, 1101)\n    RETURN = (Command.RETURN, 1011)\n    TYPES = (BREAK, CONTINUE)\n    NULL = None\n    NONE = {None, 1012}\nclass Global:\n    FILE_EXT = '.mapy'\n    FLAG_MAP = {",
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Global",
        "kind": 6,
        "importPath": "config.config",
        "description": "config.config",
        "peekOfCode": "class Global:\n    FILE_EXT = '.mapy'\n    FLAG_MAP = {\n        re.ASCII: 'a',\n        re.IGNORECASE: 'i',\n        re.LOCALE: 'l',\n        re.MULTILINE: 'm',\n        re.DOTALL: 's',\n        re.UNICODE: 'u',\n        # re.VERBOSE: 'x',",
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "config.config",
        "description": "config.config",
        "peekOfCode": "__all__ = [\"Command\", \"Event\", \"Envar\", \"KW\", \"DataType\", \"Config\", \"Return\", \"Label\", \"Global\"]\n# Commands\nclass Command:\n    ON = \"ON\"\n    INPUT = \"INPUT\"\n    IF = \"WHEN\"\n    ELIF = \"ORWHEN\"\n    ELSE = \"ELSE\"\n    OR = \"OR\"\n    AND = \"AND\"",
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Patterns",
        "kind": 6,
        "importPath": "config.patterns",
        "description": "config.patterns",
        "peekOfCode": "class Patterns:\n    LF = r'(?<![\\w\\.\\d])'\n    RG = r'(?![\\w\\.\\d])'\n    VARIABLE = rf'{LF}([@$][a-zA-Z_][a-zA-Z0-9_]*(?:\\.[a-zA-Z0-9_]+)*){RG}'\n    VARIABLE_IN = r'[@$]\\{(\\w+(?:\\.[\\w+]+)*)\\}'\n    STRING = rf'{LF}(?:\\'(?:\\\\.|[^\\'\\n\\\\])*\\'|\"(?:\\\\.|[^\\n\"\\\\])*\"){RG}'\n    ESCAPED_STRING = rf'{LF}(?:!\\'(?:\\\\.|[^\\'\\n\\\\])*\\'|!\"(?:\\\\.|[^\\n\"\\\\])*\"){RG}' \n    INTEGER = rf'{LF}(?<!\\d)-?\\d+(\\.\\d+)?([eE][-+]?\\d+)?{RG}'\n    CONTAINED = r'(?<!\\S)(\\((.*)\\))(?!\\S)'\n    OPERATOR = r'\\*\\*|[\\+\\-\\*\\(\\)/%\\^]|==|&&|\\|\\||!=|>=|<=|>|<|~~|!~~|::|!::'",
        "detail": "config.patterns",
        "documentation": {}
    },
    {
        "label": "CompiledPatterns",
        "kind": 6,
        "importPath": "config.patterns",
        "description": "config.patterns",
        "peekOfCode": "class CompiledPatterns:\n    VARIABLE = re.compile(Patterns.VARIABLE)\n    VARIABLE_IN = re.compile(Patterns.VARIABLE_IN)\n    #COMMAND = re.compile(Patterns.COMMAND)\n    STRING = re.compile(Patterns.STRING)\n    ESCAPED_STRING = re.compile(Patterns.ESCAPED_STRING)\n    INTEGER = re.compile(Patterns.INTEGER)  \n    INSIDE_ARRAY = re.compile(Patterns.INSIDE_ARRAY)\n    MULTILINE_COMMENT = re.compile(Patterns.MULTILINE_COMMENT, re.DOTALL)\n    SUPPORTED_TOKENS = re.compile(Patterns.SUPPORTED_TOKENS)",
        "detail": "config.patterns",
        "documentation": {}
    },
    {
        "label": "Runtime",
        "kind": 6,
        "importPath": "config.runtime",
        "description": "config.runtime",
        "peekOfCode": "class Runtime:\n    _instance = None\n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls, *args, **kwargs)\n            cls._instance.initialize()\n        return cls._instance\n    def initialize(self):\n        self.init()\n        # Content",
        "detail": "config.runtime",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "config.runtime",
        "description": "config.runtime",
        "peekOfCode": "__all__ = ['runtime']\nclass Runtime:\n    _instance = None\n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls, *args, **kwargs)\n            cls._instance.initialize()\n        return cls._instance\n    def initialize(self):\n        self.init()",
        "detail": "config.runtime",
        "documentation": {}
    },
    {
        "label": "runtime",
        "kind": 5,
        "importPath": "config.runtime",
        "description": "config.runtime",
        "peekOfCode": "runtime = Runtime()\nrt = runtime",
        "detail": "config.runtime",
        "documentation": {}
    },
    {
        "label": "rt",
        "kind": 5,
        "importPath": "config.runtime",
        "description": "config.runtime",
        "peekOfCode": "rt = runtime",
        "detail": "config.runtime",
        "documentation": {}
    },
    {
        "label": "Interpreter",
        "kind": 6,
        "importPath": "core.main",
        "description": "core.main",
        "peekOfCode": "class Interpreter:\n    def __init__(self):\n        init()\n    def run(self, content):\n        Config.CURRENT_RUNTIME = \"Root\"\n        # Set Working Path/File by default\n        if not rt.working_file:\n            rt.working_file = None\n            rt.working_path = os.getcwd()\n        # Process the code",
        "detail": "core.main",
        "documentation": {}
    },
    {
        "label": "init",
        "kind": 2,
        "importPath": "core.setupCore",
        "description": "core.setupCore",
        "peekOfCode": "def init():\n    # Add all commands on Runtime\n    # rt.COMMAND_SYNTAXES = {key: value[1] for key, value in COMMANDS_MAP.items()}\n    Config.COMMAND_SYNTAXES = {key: value[1] for key, value in COMMANDS_MAP.items()}\n    keys = [key for key in Config.COMMAND_SYNTAXES.keys() if isinstance(key, str) and key.strip()]\n    # rt.COMMANDS = set(keys)\n    Config.COMMANDS = set(keys)\n    #rt.update_runtime()",
        "detail": "core.setupCore",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "core.setupCore",
        "description": "core.setupCore",
        "peekOfCode": "__all__ = [\"init\"]\ndef init():\n    # Add all commands on Runtime\n    # rt.COMMAND_SYNTAXES = {key: value[1] for key, value in COMMANDS_MAP.items()}\n    Config.COMMAND_SYNTAXES = {key: value[1] for key, value in COMMANDS_MAP.items()}\n    keys = [key for key in Config.COMMAND_SYNTAXES.keys() if isinstance(key, str) and key.strip()]\n    # rt.COMMANDS = set(keys)\n    Config.COMMANDS = set(keys)\n    #rt.update_runtime()",
        "detail": "core.setupCore",
        "documentation": {}
    },
    {
        "label": "Error",
        "kind": 6,
        "importPath": "errors.error",
        "description": "errors.error",
        "peekOfCode": "class Error:\n    # Types\n    ERROR_TYPE = {\n        0: \"SyntaxError\",\n        1: \"ValueError\",\n        2: \"RuntimeError\",\n        3: \"TypeError\",\n        10: \"StructureError\",\n        20: \"FileNotFoundError\",\n        21: \"FileError\",",
        "detail": "errors.error",
        "documentation": {}
    },
    {
        "label": "throw",
        "kind": 2,
        "importPath": "errors.error",
        "description": "errors.error",
        "peekOfCode": "def throw(elem, argums=[], syntax=False):\n    error_type = Error.ERROR_TYPE.get(elem[0], \"UnknownError\")\n    error_label = elem[1]\n    error_name = get_errorname(Error, elem)\n    for i, x in enumerate(argums, 1):  # Enumerar desde 1\n        # Reemplazo del marcador numerado %1, %2, etc.\n        error_label = error_label.replace(f\"%{i}\", str(x))\n        # Reemplazo de pluralización &1, &2, etc.\n        if isinstance(x, int):\n            error_label = error_label.replace(f\"&{i}\", 's' if x != 1 else '')",
        "detail": "errors.error",
        "documentation": {}
    },
    {
        "label": "throwError",
        "kind": 2,
        "importPath": "errors.error",
        "description": "errors.error",
        "peekOfCode": "def throwError(etype, label, syntax = False, name = \"\"):\n    label = fetch_text(label)\n    file = None\n    event = rt.last_event if rt.last_event != \"\" else rt.current_event\n    if not event:\n        event = Event.GLOBAL\n    context = rt.line_context\n    if rt.working_file and rt.working_path:\n        file = os.path.relpath(rt.working_file, rt.working_path)\n    if not context:",
        "detail": "errors.error",
        "documentation": {}
    },
    {
        "label": "throwCustom",
        "kind": 2,
        "importPath": "errors.error",
        "description": "errors.error",
        "peekOfCode": "def throwCustom(text):\n    throwError('GenericError', text, False)\ndef get_syntaxes(cmd):\n    SYNTAXES = {**Config.COMMAND_SYNTAXES, **rt.CUSTOM_SYNTAXES}\n    syntaxes = SYNTAXES.get(cmd, None)\n    # Search command in modules\n    if not syntaxes and cmd in rt.GLOBAL_COMMANDS:\n        syntaxes = module_get_prop('CUSTOM_SYNTAXES', cmd)\n    if syntaxes == None:\n        syntaxes = module_get_prop('CUSTOM_SYNTAXES', cmd) ",
        "detail": "errors.error",
        "documentation": {}
    },
    {
        "label": "get_syntaxes",
        "kind": 2,
        "importPath": "errors.error",
        "description": "errors.error",
        "peekOfCode": "def get_syntaxes(cmd):\n    SYNTAXES = {**Config.COMMAND_SYNTAXES, **rt.CUSTOM_SYNTAXES}\n    syntaxes = SYNTAXES.get(cmd, None)\n    # Search command in modules\n    if not syntaxes and cmd in rt.GLOBAL_COMMANDS:\n        syntaxes = module_get_prop('CUSTOM_SYNTAXES', cmd)\n    if syntaxes == None:\n        syntaxes = module_get_prop('CUSTOM_SYNTAXES', cmd) \n    lines = []\n    if syntaxes is None: return ''",
        "detail": "errors.error",
        "documentation": {}
    },
    {
        "label": "get_errorname",
        "kind": 2,
        "importPath": "errors.error",
        "description": "errors.error",
        "peekOfCode": "def get_errorname(obj, value):\n    for name, val in vars(obj).items():\n        if val == value:\n            return name\n    return None  # Si la variable no se encuentra\ndef fetch_text(text):\n    return output_text(text)",
        "detail": "errors.error",
        "documentation": {}
    },
    {
        "label": "fetch_text",
        "kind": 2,
        "importPath": "errors.error",
        "description": "errors.error",
        "peekOfCode": "def fetch_text(text):\n    return output_text(text)",
        "detail": "errors.error",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "errors.error",
        "description": "errors.error",
        "peekOfCode": "__all__ = ['Error', 'throw', 'throwCustom', 'throwError']\ninit()\n# Runtime\nclass Error:\n    # Types\n    ERROR_TYPE = {\n        0: \"SyntaxError\",\n        1: \"ValueError\",\n        2: \"RuntimeError\",\n        3: \"TypeError\",",
        "detail": "errors.error",
        "documentation": {}
    },
    {
        "label": "split_ext",
        "kind": 2,
        "importPath": "internal.helpers",
        "description": "internal.helpers",
        "peekOfCode": "def split_ext(string:str, token:str = '', times = -1):\n    if token == '':\n        return list(string)\n    else:\n        return string.split(token)",
        "detail": "internal.helpers",
        "documentation": {}
    },
    {
        "label": "NodeCondition",
        "kind": 6,
        "importPath": "internal.processing",
        "description": "internal.processing",
        "peekOfCode": "class NodeCondition:\n    def __init__(self, name, indent = 0):\n        self.name = name\n        self.content = {}\n        for x in Config.EVENTS:\n            self.content.update({x : []})\n        self.indent = indent\n# Main process\ndef main_process(content):\n    # Run process",
        "detail": "internal.processing",
        "documentation": {}
    },
    {
        "label": "main_process",
        "kind": 2,
        "importPath": "internal.processing",
        "description": "internal.processing",
        "peekOfCode": "def main_process(content):\n    # Run process\n    root, imports = process(content)\n    res_dict = tree_to_dict(root)\n    postprocess()\n    run_all_events(res_dict)\n# Process all the code and return a tree\ndef process(code):\n    # Options\n    root = NodeCondition(\"Root\")",
        "detail": "internal.processing",
        "documentation": {}
    },
    {
        "label": "process",
        "kind": 2,
        "importPath": "internal.processing",
        "description": "internal.processing",
        "peekOfCode": "def process(code):\n    # Options\n    root = NodeCondition(\"Root\")\n    current_node = root\n    stack = []\n    imports = []\n    on_def = []\n    on_loop = []\n    # Replace special characters\n    code = adjust_strings(code)",
        "detail": "internal.processing",
        "documentation": {}
    },
    {
        "label": "tree_to_dict",
        "kind": 2,
        "importPath": "internal.processing",
        "description": "internal.processing",
        "peekOfCode": "def tree_to_dict(node):\n    dictionary = {}\n    for event, lines in node.content.items():\n        for item in lines:\n            if isinstance(item, list):  # If it's a subcondition\n                sub_condition, sub_node = item\n                sub_dictionary = tree_to_dict(sub_node)\n                if sub_dictionary:\n                    sub_dictionary_key = sub_dictionary[next(iter(sub_dictionary))]\n                    dictionary.setdefault(event, []).append({sub_condition: sub_dictionary_key})",
        "detail": "internal.processing",
        "documentation": {}
    },
    {
        "label": "postprocess",
        "kind": 2,
        "importPath": "internal.processing",
        "description": "internal.processing",
        "peekOfCode": "def postprocess():\n    map = rt.command_tree\n    # Check command tree\n    for key, lines in map.items():\n        for index, line in enumerate(lines):\n            parts = tuple(line.split('#'))\n            line_number = int(get_element(parts, 1, 0))\n            line_content = parts[0].strip()\n            cmd_parts = tuple(line_content.split(' ', 1))\n            cmd = get_element(cmd_parts, 0, None)",
        "detail": "internal.processing",
        "documentation": {}
    },
    {
        "label": "run_all_events",
        "kind": 2,
        "importPath": "internal.processing",
        "description": "internal.processing",
        "peekOfCode": "def run_all_events(root: dict):\n    lines = []\n    if rt.content != None:\n        #lines = rt.content.split('\\n')\n        #envar_set(Envar.LINES, lines)\n        envar_set(Envar.CONTENT, rt.content)\n        envar_set(Envar.STORED, rt.stored)\n    # Run the events in order\n    if Event.START in root:\n        run_event(root, Event.START)",
        "detail": "internal.processing",
        "documentation": {}
    },
    {
        "label": "run_event",
        "kind": 2,
        "importPath": "internal.processing",
        "description": "internal.processing",
        "peekOfCode": "def run_event(root, event):\n    rt.last_event = event\n    try:\n        for line in root.get(event, []):\n            if line:\n                if isinstance(line, dict):\n                    execute_block(line)\n                else:\n                    execute_line(line)\n    finally:",
        "detail": "internal.processing",
        "documentation": {}
    },
    {
        "label": "process_import",
        "kind": 2,
        "importPath": "internal.processing",
        "description": "internal.processing",
        "peekOfCode": "def process_import(file, line):\n    original_runtime = rt.current_runtime\n    id = Config.CURRENT_MODULE\n    module_id = str(uuid.uuid4())\n    rt.MODULES_ID.update({\n        Config.CURRENT_MODULE: module_id\n    })\n    # Log\n    register_import(original_runtime, id)\n    CurrentContext = rt.save_context(original_runtime)",
        "detail": "internal.processing",
        "documentation": {}
    },
    {
        "label": "handle_error",
        "kind": 2,
        "importPath": "internal.processing",
        "description": "internal.processing",
        "peekOfCode": "def handle_error(line_number, prev_sibling, line_content, cmd, error_type):\n    prev_line = f'{prev_sibling}\\n' if prev_sibling else ''\n    rt.runtime_line(line_number)\n    rt.runtime_context(f'{prev_line}{line_content}')\n    rt.runtime_cmd(cmd)\n    throw(error_type, [cmd])\ndef adjust_strings(text = '', hard = False):\n    combined_pattern = re.compile(f\"{Patterns.STRING}|{Patterns.ESCAPED_STRING}\")\n    def replace_char(match):\n        matched_string = match.group(0).replace('\\n', r'\\n')",
        "detail": "internal.processing",
        "documentation": {}
    },
    {
        "label": "adjust_strings",
        "kind": 2,
        "importPath": "internal.processing",
        "description": "internal.processing",
        "peekOfCode": "def adjust_strings(text = '', hard = False):\n    combined_pattern = re.compile(f\"{Patterns.STRING}|{Patterns.ESCAPED_STRING}\")\n    def replace_char(match):\n        matched_string = match.group(0).replace('\\n', r'\\n')\n        fs = ''\n        if matched_string.startswith('!'):\n            sign = matched_string[1]\n            fs = '!'\n            matched_string = matched_string[2:-1]\n        else:",
        "detail": "internal.processing",
        "documentation": {}
    },
    {
        "label": "get_exports",
        "kind": 2,
        "importPath": "internal.processing",
        "description": "internal.processing",
        "peekOfCode": "def get_exports():\n    exp_vars = []\n    exp_cmds = []\n    for x in rt.export_list:\n        type = x['type']\n        src = x['src']\n        module = x['module']\n        if type == 'var':\n            #value = rt.get_var(src)\n            exp_vars.append({\"name\": src, 'module': module})",
        "detail": "internal.processing",
        "documentation": {}
    },
    {
        "label": "register_exports",
        "kind": 2,
        "importPath": "internal.processing",
        "description": "internal.processing",
        "peekOfCode": "def register_exports(vars, cmds, id):\n    for var in vars:\n        name = str(var['name']).strip('$')\n        var_id = var['module']\n        rt.GLOBAL_PROPS.update({\n            name: [var_id]\n        })\n        #print(f\"Registrying {name} into: {id} | {rt.current_runtime}\")\n    # Register command\n    for cmd in cmds:",
        "detail": "internal.processing",
        "documentation": {}
    },
    {
        "label": "register_import",
        "kind": 2,
        "importPath": "internal.processing",
        "description": "internal.processing",
        "peekOfCode": "def register_import(module_name: str, imported_module_name: str):\n    \"\"\"\n    Registra una importación y verifica si hay un ciclo de importación.\n    Args:\n        module_name (str): El nombre del módulo que realiza la importación.\n        imported_module_name (str): El nombre del módulo que se está importando.\n    Raises:\n        RuntimeError: Si se detecta una importación circular.\n    \"\"\"\n    module1 = module_name",
        "detail": "internal.processing",
        "documentation": {}
    },
    {
        "label": "has_circular_import",
        "kind": 2,
        "importPath": "internal.processing",
        "description": "internal.processing",
        "peekOfCode": "def has_circular_import(module_name, imported_module_name, visited=None):\n    \"\"\"\n    Verifica si la importación crea un ciclo de importación.\n    Args:\n        module_name (str): El nombre del módulo que realiza la importación.\n        imported_module_name (str): El nombre del módulo que se está importando.\n        visited (set): Un conjunto de módulos ya visitados en la búsqueda.\n    Returns:\n        bool: True si se detecta un ciclo de importación, False en caso contrario.\n    \"\"\"",
        "detail": "internal.processing",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "internal.processing",
        "description": "internal.processing",
        "peekOfCode": "__all__ = ['process', 'tree_to_dict', 'postprocess', 'run_all_events', 'run_event']\nruntime_stack = Stack()\nimported_modules = set()\nmodule_imports = {}\n# Class to make blocks of codes\nclass NodeCondition:\n    def __init__(self, name, indent = 0):\n        self.name = name\n        self.content = {}\n        for x in Config.EVENTS:",
        "detail": "internal.processing",
        "documentation": {}
    },
    {
        "label": "runtime_stack",
        "kind": 5,
        "importPath": "internal.processing",
        "description": "internal.processing",
        "peekOfCode": "runtime_stack = Stack()\nimported_modules = set()\nmodule_imports = {}\n# Class to make blocks of codes\nclass NodeCondition:\n    def __init__(self, name, indent = 0):\n        self.name = name\n        self.content = {}\n        for x in Config.EVENTS:\n            self.content.update({x : []})",
        "detail": "internal.processing",
        "documentation": {}
    },
    {
        "label": "imported_modules",
        "kind": 5,
        "importPath": "internal.processing",
        "description": "internal.processing",
        "peekOfCode": "imported_modules = set()\nmodule_imports = {}\n# Class to make blocks of codes\nclass NodeCondition:\n    def __init__(self, name, indent = 0):\n        self.name = name\n        self.content = {}\n        for x in Config.EVENTS:\n            self.content.update({x : []})\n        self.indent = indent",
        "detail": "internal.processing",
        "documentation": {}
    },
    {
        "label": "module_imports",
        "kind": 5,
        "importPath": "internal.processing",
        "description": "internal.processing",
        "peekOfCode": "module_imports = {}\n# Class to make blocks of codes\nclass NodeCondition:\n    def __init__(self, name, indent = 0):\n        self.name = name\n        self.content = {}\n        for x in Config.EVENTS:\n            self.content.update({x : []})\n        self.indent = indent\n# Main process",
        "detail": "internal.processing",
        "documentation": {}
    },
    {
        "label": "check_conditions",
        "kind": 2,
        "importPath": "misc.conditions copy",
        "description": "misc.conditions copy",
        "peekOfCode": "def check_conditions(conditions):\n    # Variables para evaluar las condiciones\n    or_groups = []\n    current_group = []\n    for condition in conditions:\n        condition = condition.strip()\n        if condition.startswith(Config.OR_COMMAND):\n            if current_group:\n                or_groups.append(current_group)\n            current_group = [condition.strip()]  # Add the condition after 'OR'",
        "detail": "misc.conditions copy",
        "documentation": {}
    },
    {
        "label": "parse_condition",
        "kind": 2,
        "importPath": "misc.conditions copy",
        "description": "misc.conditions copy",
        "peekOfCode": "def parse_condition(line):\n    line_parts = line.split(' ', 1)\n    cmd = get_element(line_parts, 0)\n    params = get_element(line_parts, 1, None)\n    checked_syntax, tokens, _ = check_command(cmd, params, line)\n    return evaluate_condition(checked_syntax, tokens)\ndef evaluate_conditionx(params, token_params):\n    n_params = len(params)\n    arg = lambda n : get_element(params, n - 1, None)\n    validations = [",
        "detail": "misc.conditions copy",
        "documentation": {}
    },
    {
        "label": "evaluate_conditionx",
        "kind": 2,
        "importPath": "misc.conditions copy",
        "description": "misc.conditions copy",
        "peekOfCode": "def evaluate_conditionx(params, token_params):\n    n_params = len(params)\n    arg = lambda n : get_element(params, n - 1, None)\n    validations = [\n        [\"%\"],\n        [\"NOT\", \"%\"],\n        # IS\n        [\"%\", \"IS\", \"%\"],\n        [\"%\", \"IS NOT\", \"%\"],\n        # Greather than",
        "detail": "misc.conditions copy",
        "documentation": {}
    },
    {
        "label": "evaluate_condition",
        "kind": 2,
        "importPath": "misc.conditions copy",
        "description": "misc.conditions copy",
        "peekOfCode": "def evaluate_condition(params, token_params):\n    n_params = len(params)\n    arg = lambda n: get_element(params, n - 1, None)\n    # Diccionario para las validaciones y sus nombres correspondientes\n    validations = {\n        (1, \"%\"): \"[self]\",\n        (2, \"NOT\", \"%\"): \"[non_self]\",\n        (2, \"%\", \"IS\", \"%\"): \"[is_equal]\",\n        (2, \"%\", \"IS NOT\", \"%\"): \"[is_not_equal]\",\n        (3, \"%\", \"IS\", \"GT\", \"%\"): \"[is_gt]\",",
        "detail": "misc.conditions copy",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "misc.conditions copy",
        "description": "misc.conditions copy",
        "peekOfCode": "__all__ = ['check_conditions', 'parse_condition', 'evaluate_condition']\ndef check_conditions(conditions):\n    # Variables para evaluar las condiciones\n    or_groups = []\n    current_group = []\n    for condition in conditions:\n        condition = condition.strip()\n        if condition.startswith(Config.OR_COMMAND):\n            if current_group:\n                or_groups.append(current_group)",
        "detail": "misc.conditions copy",
        "documentation": {}
    },
    {
        "label": "tokenize_line",
        "kind": 2,
        "importPath": "misc.parser copy",
        "description": "misc.parser copy",
        "peekOfCode": "def tokenize_line(line: str):\n    tokens_found = []\n    not_found = []\n    if line is None:\n        return tokens_found, not_found\n    # Define a combined pattern\n    all_cmds = Config.COMMANDS + r.EXTEND_COMMANDS\n    COMMAND = r'\\b(?:' + '|'.join(all_cmds) + r')\\b'\n    SUPPORTED_TOKENS = (\n        rf'({Patterns.ARRAY})|'",
        "detail": "misc.parser copy",
        "documentation": {}
    },
    {
        "label": "check_syntax",
        "kind": 2,
        "importPath": "misc.parser copy",
        "description": "misc.parser copy",
        "peekOfCode": "def check_syntax(cmd, params):\n    # Get the syntax from the current command\n    cmd_syntax = Config.COMMAND_SYNTAX.get(cmd, None)\n    if not cmd_syntax:\n        cmd_syntax = r.EXTEND_COMMAND_SYNTAX.get(cmd, None)\n    if not cmd_syntax:\n        throw(e.UNKNOWN_COMMAND, [\"cmd\"])\n    # Filter syntaxes with same parameters\n    match_params = []\n    params_count = [len(sublist) for sublist in cmd_syntax]",
        "detail": "misc.parser copy",
        "documentation": {}
    },
    {
        "label": "check_command",
        "kind": 2,
        "importPath": "misc.parser copy",
        "description": "misc.parser copy",
        "peekOfCode": "def check_command(cmd, params, line):\n    tokens_found, not_found = tokenize_line(params)\n    if not_found:\n        targ = not_found[0]\n        if targ in Config.COMMANDS or targ in r.EXTEND_COMMANDS:\n            throw(e.INVALID_COMMAND_INVOCATION, [targ])\n        else:\n            throw(e.INVALID_SYNTAX, [targ])\n    checked_syntax, current_syntax = check_syntax(cmd, tokens_found)\n    return checked_syntax, tokens_found, current_syntax",
        "detail": "misc.parser copy",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "misc.parser copy",
        "description": "misc.parser copy",
        "peekOfCode": "__all__ = ['tokenize_line']\n# Runtime\nr = Runtime()\ndef tokenize_line(line: str):\n    tokens_found = []\n    not_found = []\n    if line is None:\n        return tokens_found, not_found\n    # Define a combined pattern\n    all_cmds = Config.COMMANDS + r.EXTEND_COMMANDS",
        "detail": "misc.parser copy",
        "documentation": {}
    },
    {
        "label": "r",
        "kind": 5,
        "importPath": "misc.parser copy",
        "description": "misc.parser copy",
        "peekOfCode": "r = Runtime()\ndef tokenize_line(line: str):\n    tokens_found = []\n    not_found = []\n    if line is None:\n        return tokens_found, not_found\n    # Define a combined pattern\n    all_cmds = Config.COMMANDS + r.EXTEND_COMMANDS\n    COMMAND = r'\\b(?:' + '|'.join(all_cmds) + r')\\b'\n    SUPPORTED_TOKENS = (",
        "detail": "misc.parser copy",
        "documentation": {}
    },
    {
        "label": "sep_array",
        "kind": 2,
        "importPath": "parser.parser",
        "description": "parser.parser",
        "peekOfCode": "def sep_array(array):\n    unique_items = list(dict.fromkeys(array))  # Eliminar duplicados manteniendo el orden\n    if len(unique_items) > 2:\n        return \", \".join(unique_items[:-1]) + \" or \" + unique_items[-1]\n    else:\n        return \" or \".join(unique_items)\n# Tokeniza y verifica una sintaxis\ndef check_command(cmd: str, params: str, line, env={}, onlyTokens=False):\n    # Tokenizar la linea para obtener los componentes\n    tokens_found, not_found = tokenize_line(params, cmd)",
        "detail": "parser.parser",
        "documentation": {}
    },
    {
        "label": "check_command",
        "kind": 2,
        "importPath": "parser.parser",
        "description": "parser.parser",
        "peekOfCode": "def check_command(cmd: str, params: str, line, env={}, onlyTokens=False):\n    # Tokenizar la linea para obtener los componentes\n    tokens_found, not_found = tokenize_line(params, cmd)\n    not_found = \"\".join(not_found)\n    # Si hay tokens desconocidos\n    if not_found:\n        targ = not_found.split(' ', 1)[0]\n        commands = get_all_commands()\n        if targ in commands:\n            throw(e.INVALID_COMMAND_INVOCATION, [targ])",
        "detail": "parser.parser",
        "documentation": {}
    },
    {
        "label": "tokenize_line",
        "kind": 2,
        "importPath": "parser.parser",
        "description": "parser.parser",
        "peekOfCode": "def tokenize_line(line: str, cmd = ''):\n    if not line:\n        return [], []\n    # Extraer paréntesis, arrays y mapas anidados\n    special_chars = ['[', '(', '{']\n    positions = [(char, line.find(char)) for char in special_chars if char in line]\n    order = sorted(positions, key=lambda x: x[1])\n    parentheses_markers, arrays_markers, maps_markers = [], [], []\n    parentheses = extract_nested_structures(line, '(', ')')    \n    arrays = extract_nested_structures(line, '[', ']')",
        "detail": "parser.parser",
        "documentation": {}
    },
    {
        "label": "merge_tokens",
        "kind": 2,
        "importPath": "parser.parser",
        "description": "parser.parser",
        "peekOfCode": "def merge_tokens(final_tokens, cmd):\n    current = []\n    tokens = []\n    has_operations = False\n    i = 0\n    block = False\n    final_tokens = tuple(final_tokens)\n    while i < len(final_tokens):\n        t = final_tokens[i]\n        next:str = get_element(final_tokens, i+1, '')",
        "detail": "parser.parser",
        "documentation": {}
    },
    {
        "label": "check_syntax",
        "kind": 2,
        "importPath": "parser.parser",
        "description": "parser.parser",
        "peekOfCode": "def check_syntax(cmd: str, params: list, env: dict={}):\n    # Get the syntax from the current command\n    SYNTAXES = {**Config.COMMAND_SYNTAXES, **rt.CUSTOM_SYNTAXES}\n    cmd_syntax = SYNTAXES.get(cmd, None)\n    # Search command in modules\n    if not cmd_syntax and cmd in rt.GLOBAL_COMMANDS:\n        cmd_syntax = module_get_prop('CUSTOM_SYNTAXES', cmd)\n    # Check if command exists\n    if not cmd_syntax:\n        throw(e.UNKNOWN_COMMAND, [cmd])",
        "detail": "parser.parser",
        "documentation": {}
    },
    {
        "label": "resolve_param",
        "kind": 2,
        "importPath": "parser.parser",
        "description": "parser.parser",
        "peekOfCode": "def resolve_param(token):\n    r_type = type_of(token)\n    if r_type == 'variable':\n        return [token, 'VAR']\n    elif r_type == 'array':\n        return [token, '_ARRAY']\n    value = resolve_value(token, vars=False)\n    return [value, type_name(value)]\ndef match_syntax(syntax, params, rawparams, last):\n    if not syntax:",
        "detail": "parser.parser",
        "documentation": {}
    },
    {
        "label": "match_syntax",
        "kind": 2,
        "importPath": "parser.parser",
        "description": "parser.parser",
        "peekOfCode": "def match_syntax(syntax, params, rawparams, last):\n    if not syntax:\n        return {'Empty'}\n    resolved_tokens = []\n    def add_token(value):\n        resolved_tokens.append(value)\n    # Define a function\n    def check_token(token, value, rawvalue, typen, onloop = False):\n        # (Connectors)\n        if token in Config.CONNECTORS:",
        "detail": "parser.parser",
        "documentation": {}
    },
    {
        "label": "priority_order",
        "kind": 2,
        "importPath": "parser.parser",
        "description": "parser.parser",
        "peekOfCode": "def priority_order(item):\n    # priority = Config.PARAMS_PRIORITY\n    # try: return priority.index(item)\n    # except ValueError: return len(priority) \n    return Config.PARAMS_PRIORITY.index(item) if item in Config.PARAMS_PRIORITY else len(Config.PARAMS_PRIORITY)\ndef filter_syntax_by_param_count(cmd_syntax, n_params):\n    syntax_by_param_count = defaultdict(list)\n    for index, syntax in enumerate(cmd_syntax):\n        syntax_by_param_count[len(syntax)].append((index, syntax))\n    return syntax_by_param_count.get(n_params, [])",
        "detail": "parser.parser",
        "documentation": {}
    },
    {
        "label": "filter_syntax_by_param_count",
        "kind": 2,
        "importPath": "parser.parser",
        "description": "parser.parser",
        "peekOfCode": "def filter_syntax_by_param_count(cmd_syntax, n_params):\n    syntax_by_param_count = defaultdict(list)\n    for index, syntax in enumerate(cmd_syntax):\n        syntax_by_param_count[len(syntax)].append((index, syntax))\n    return syntax_by_param_count.get(n_params, [])\ndef handle_invalid_params(cmd, n_params, params_count):\n    min_params, max_params = min(params_count), max(params_count)\n    onesyn = len(params_count) == 1\n    # Handle errors\n    if n_params > max_params and onesyn:",
        "detail": "parser.parser",
        "documentation": {}
    },
    {
        "label": "handle_invalid_params",
        "kind": 2,
        "importPath": "parser.parser",
        "description": "parser.parser",
        "peekOfCode": "def handle_invalid_params(cmd, n_params, params_count):\n    min_params, max_params = min(params_count), max(params_count)\n    onesyn = len(params_count) == 1\n    # Handle errors\n    if n_params > max_params and onesyn:\n        throw(e.EXACT_PARAMS, [cmd, max_params, n_params], 1)\n    elif n_params > max_params:\n        if min_params == max_params:\n            throw(e.EXACT_PARAMS, [cmd, max_params, n_params], 1)\n        else:",
        "detail": "parser.parser",
        "documentation": {}
    },
    {
        "label": "replace_structures_with_markers",
        "kind": 2,
        "importPath": "parser.parser",
        "description": "parser.parser",
        "peekOfCode": "def replace_structures_with_markers(text, structures, marker_template):\n    markers = []\n    for i, s in enumerate(structures):\n        marker = marker_template.format(i)\n        text = text.replace(s, marker, 1)\n        markers.append(marker)\n    return text, markers\ndef reintegrate_structures(tokens, markers, structures):\n    final_tokens = []\n    for token in tokens:",
        "detail": "parser.parser",
        "documentation": {}
    },
    {
        "label": "reintegrate_structures",
        "kind": 2,
        "importPath": "parser.parser",
        "description": "parser.parser",
        "peekOfCode": "def reintegrate_structures(tokens, markers, structures):\n    final_tokens = []\n    for token in tokens:\n        for i, marker in enumerate(markers):\n            if marker in token:\n                token = token.replace(marker, structures[i])\n        final_tokens.append(token)\n    return final_tokens",
        "detail": "parser.parser",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "parser.parser",
        "description": "parser.parser",
        "peekOfCode": "__all__ = ['tokenize_line', 'check_command']\ndef sep_array(array):\n    unique_items = list(dict.fromkeys(array))  # Eliminar duplicados manteniendo el orden\n    if len(unique_items) > 2:\n        return \", \".join(unique_items[:-1]) + \" or \" + unique_items[-1]\n    else:\n        return \" or \".join(unique_items)\n# Tokeniza y verifica una sintaxis\ndef check_command(cmd: str, params: str, line, env={}, onlyTokens=False):\n    # Tokenizar la linea para obtener los componentes",
        "detail": "parser.parser",
        "documentation": {}
    },
    {
        "label": "Resolved",
        "kind": 6,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "class Resolved:\n    def __init__(self, value):\n        self.value = value\n#@hcache()\ndef type_of(data: str):\n    if isinstance(data, tuple):\n        return \"math\"\n    ordata = data\n    data = str(data)\n    if CompiledPatterns.ESCAPED_STRING.fullmatch(data):",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "type_of",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def type_of(data: str):\n    if isinstance(data, tuple):\n        return \"math\"\n    ordata = data\n    data = str(data)\n    if CompiledPatterns.ESCAPED_STRING.fullmatch(data):\n        return 'estring'\n    elif CompiledPatterns.STRING.fullmatch(data):\n        return 'string'\n    elif CompiledPatterns.VARIABLE.fullmatch(data):",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "resolve_value",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def resolve_value(val, raw=False, vars=True, onStruct=False):\n    t = type_of(val)\n    match t:\n        # (Numbers)\n        case 'number':\n            return resolve_number(val)\n        # (Variables)\n        case 'variable':\n            if vars:\n                return var_get(val)",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "resolve_number",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def resolve_number(val):\n    floatn = float(val)\n    if 'e' in val or '.' in val:\n        return floatn\n    if math.isinf(floatn):\n        return 'INFINITY'\n    return int(val)\n# (STRINGS)\ndef resolve_string(string:str, raw=False):\n    string = output_text(string)",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "resolve_string",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def resolve_string(string:str, raw=False):\n    string = output_text(string)\n    if not raw and rt.last_cmd != Command.ESCAPE:\n        string = decode_text(string)\n    return string\ndef resolve_variables(data:str):\n    # Interpolate variables in strings\n    strings = CompiledPatterns.STRING.findall(data)\n    for string in strings:\n        data = data.replace(string, resolve_string(string))",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "resolve_variables",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def resolve_variables(data:str):\n    # Interpolate variables in strings\n    strings = CompiledPatterns.STRING.findall(data)\n    for string in strings:\n        data = data.replace(string, resolve_string(string))\n    # Variables\n    vars = CompiledPatterns.VARIABLE.findall(data)\n    for var in vars:\n        res = var_get(var)\n        templ = f'\"{res}\"'",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "resolve_special_keyword",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def resolve_special_keyword(kw):\n    res = Config.KEYWORDS_VALUES.get(kw, 'none')\n    if res == 'none': return None\n    else: return res\n# (ARRAYS)\ndef resolve_array(arr, raw=False, vars=True, struct=False):\n    from .parser import check_command\n    array = arr[1:-1].strip()\n    elements = split_elements(array)\n    nw = []",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "resolve_array",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def resolve_array(arr, raw=False, vars=True, struct=False):\n    from .parser import check_command\n    array = arr[1:-1].strip()\n    elements = split_elements(array)\n    nw = []\n    for el in elements:\n        el = el.strip()\n        if not el: throw(e.INVALID_ARRAY)\n        tokens = check_command(None, el, '', onlyTokens=True)\n        if len(tokens) > 1: throw(e.INVALID_CONNECTION, [tokens[0], tokens[1]])",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "resolve_map",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def resolve_map(map, raw=False, vars=True, struct=False):\n    from .parser import check_command\n    map = map[1:-1].strip()\n    elements = split_elements(map)\n    nw = {}\n    for el in elements:\n        el = el.strip()\n        if not el: throw(e.INVALID_MAP)\n        # Divide\n        key, value = split_key_value(el, ':')",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "resolve_operation",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def resolve_operation(arr: list):\n    def process_operations(arr, operators):\n        temp = []\n        i = 0\n        while i < len(arr):\n            if arr[i] in operators:\n                operator = arr[i]\n                if operator == KW.NOT:\n                    x = arr[i + 1]\n                    if isinstance(x, bool): x = str(x).upper()",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "resolve_contained",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def resolve_contained(data:str):\n    from .parser import check_command\n    negative = False\n    if data[0] == '-':\n        data = data[2:-1]\n        negative = True\n    else:\n        data = data[1:-1]\n    tokens = check_command(rt.last_cmd, data, '', onlyTokens=True)\n    if len(tokens) == 0:",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "resolve_kw",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def resolve_kw(value, kw):\n    match kw:\n        case KW.EMPTY: return is_empty(value)\n        case KW.STRING: return type_name(value) == DataType.STRING\n        case KW.NUMBER: return type_name(value) == DataType.NUMBER\n        case KW.MAP: return type_name(value) == DataType.MAP\n        case KW.BOOL: return type_name(value) == DataType.BOOL\n        case KW.ARRAY: return type_name(value) == DataType.ARRAY\n        case KW.PATTERN: return type_name(value) == DataType.PATTERN\n        #case KW.INFINITY: return value == DataType.ARRAY",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "apply_operator",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def apply_operator(operand1, operand2, operator, tokens = []):\n    raw1 = get_element(tokens, 0, None)\n    raw2 = get_element(tokens, 1, None)\n    # Check\n    if operator in ('>', '>=', '<', '<=', KW.IS_LT, KW.IS_LEQ, KW.IS_GT, KW.IS_GEQ, KW.IS_NOT_GEQ, KW.IS_NOT_GT, KW.IS_NOT_LEQ, KW.IS_NOT_LT):\n        if not isinstance(operand1, (int, float)) or not isinstance(operand2, (int, float)):\n            throw(e.INVALID_COMPARISON_TYPE, [operator])\n    if operator == '*':\n        return multiply_values(operand1, operand2)\n    elif operator == '^' or operator == '**':",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "add_values",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def add_values(val1, val2):\n    # Number + Number\n    if isinstance(val1, (int, float)) and isinstance(val2, (int, float)):\n        return val1 + val2\n    # String + Any\n    elif isinstance(val1, str):\n        return val1 + str(val2)\n    # Array + Array\n    elif isinstance(val1, list):\n        if not isinstance(val2, list):",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "subtract_values",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def subtract_values(val1, val2):\n    if not isinstance(val1, (int, float)) or not isinstance(val2, (int, float)):\n        throw(e.INVALID_OPERATION_SUB, [type_name(val2), type_name(val1)])\n    return val1 - val2\ndef multiply_values(val1, val2):\n    if not (isinstance(val1, (int, float)) and isinstance(val2, (int, float))):\n        throw(e.INVALID_OPERATION_MUL, [type_name(val1), type_name(val2)])\n    return val1 * val2\ndef divide_values(val1, val2):\n    if not (isinstance(val1, (int, float)) and isinstance(val2, (int, float))):",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "multiply_values",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def multiply_values(val1, val2):\n    if not (isinstance(val1, (int, float)) and isinstance(val2, (int, float))):\n        throw(e.INVALID_OPERATION_MUL, [type_name(val1), type_name(val2)])\n    return val1 * val2\ndef divide_values(val1, val2):\n    if not (isinstance(val1, (int, float)) and isinstance(val2, (int, float))):\n        throw(e.INVALID_OPERATION_DIV, [type_name(val1), type_name(val2)])\n    if val2 == 0:\n        throw(e.MATH_DIVISION_ZERO)\n    return val1 / val2",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "divide_values",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def divide_values(val1, val2):\n    if not (isinstance(val1, (int, float)) and isinstance(val2, (int, float))):\n        throw(e.INVALID_OPERATION_DIV, [type_name(val1), type_name(val2)])\n    if val2 == 0:\n        throw(e.MATH_DIVISION_ZERO)\n    return val1 / val2\ndef mod_values(val1, val2):\n    if not (isinstance(val1, (int, float)) and isinstance(val2, (int, float))):\n        throw(e.INVALID_OPERATION_MOD, [type_name(val1), type_name(val2)])\n    if val2 == 0:",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "mod_values",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def mod_values(val1, val2):\n    if not (isinstance(val1, (int, float)) and isinstance(val2, (int, float))):\n        throw(e.INVALID_OPERATION_MOD, [type_name(val1), type_name(val2)])\n    if val2 == 0:\n        throw(e.MATH_MODULO_ZERO)\n    return val1 % val2\ndef logical_and(operand1, operand2):\n    # Implementación del operador lógico AND\n    return bool(operand1 and operand2)\ndef logical_not(operand):",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "logical_and",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def logical_and(operand1, operand2):\n    # Implementación del operador lógico AND\n    return bool(operand1 and operand2)\ndef logical_not(operand):\n    return not operand\ndef logical_or(operand1, operand2):\n    return operand1 or operand2\ndef logical_in(operand1, operand2):\n    type_1 = type_name(operand1)\n    type_2 = type_name(operand2)",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "logical_not",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def logical_not(operand):\n    return not operand\ndef logical_or(operand1, operand2):\n    return operand1 or operand2\ndef logical_in(operand1, operand2):\n    type_1 = type_name(operand1)\n    type_2 = type_name(operand2)\n    if isinstance(operand2, str):\n            if not isinstance(operand1, str):\n                throw(e.INVALID_IN_OPERAND, [type_1, type_2])",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "logical_or",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def logical_or(operand1, operand2):\n    return operand1 or operand2\ndef logical_in(operand1, operand2):\n    type_1 = type_name(operand1)\n    type_2 = type_name(operand2)\n    if isinstance(operand2, str):\n            if not isinstance(operand1, str):\n                throw(e.INVALID_IN_OPERAND, [type_1, type_2])\n    elif isinstance(operand2, dict):\n        if not isinstance(operand1, (str, int, float)):",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "logical_in",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def logical_in(operand1, operand2):\n    type_1 = type_name(operand1)\n    type_2 = type_name(operand2)\n    if isinstance(operand2, str):\n            if not isinstance(operand1, str):\n                throw(e.INVALID_IN_OPERAND, [type_1, type_2])\n    elif isinstance(operand2, dict):\n        if not isinstance(operand1, (str, int, float)):\n            throw(e.INVALID_IN_OPERAND, [type_1, type_2])\n    elif isinstance(operand2, list):",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "compare_values",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def compare_values(val1, val2, method):\n    match method:\n        case '==': return val1 == val2\n        case '!=': return val1 != val2\n        case '>=': return val1 >= val2\n        case '<=': return val1 <= val2\n        case '<': return val1 < val2\n        case '>': return val1 > val2\n        # case '<=': return val1 <= val2\n    return False",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "split_elements",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def split_elements(array):\n    elements = []\n    current = \"\"\n    stack = []\n    inside_string = False\n    string_char = ''\n    for char in array:\n        if char in ['\"', \"'\"]:\n            if inside_string:\n                if char == string_char:",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "split_key_value",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def split_key_value(element, delimiter):\n    inside_string = False\n    string_char = ''\n    stack = []\n    key = \"\"\n    value = \"\"\n    found_delimiter = False\n    for char in element:\n        if char in ['\"', \"'\"]:\n            if inside_string:",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "extract_nested_structures",
        "kind": 2,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "def extract_nested_structures(text:str, open_char, close_char,error=True, to_open_char=None, to_close_char=None):\n    stack = []\n    result = []\n    current = []\n    to_open_char = open_char if to_open_char is None else to_open_char\n    to_close_char = close_char if to_close_char is None else to_close_char\n    if open_char and close_char in text:\n        for char in text:\n            if char == open_char:\n                if stack:",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "parser.utils",
        "description": "parser.utils",
        "peekOfCode": "__all__ = ['type_of', 'resolve_value', 'resolve_string', 'resolve_variables', 'resolve_operation', 'extract_nested_structures']\nclass Resolved:\n    def __init__(self, value):\n        self.value = value\n#@hcache()\ndef type_of(data: str):\n    if isinstance(data, tuple):\n        return \"math\"\n    ordata = data\n    data = str(data)",
        "detail": "parser.utils",
        "documentation": {}
    },
    {
        "label": "get_element",
        "kind": 2,
        "importPath": "utils.data_utils",
        "description": "utils.data_utils",
        "peekOfCode": "def get_element(array_, index, default=None):\n    return array_[index] if 0 <= index < len(array_) else default\ndef is_array_of_type(_array, _type):\n    return all(isinstance(elemento, _type) for elemento in _array)\ndef is_array_of_var(_array):\n    return all(isinstance(elem, str) and CompiledPatterns.VARIABLE.fullmatch(elem) for elem in _array)\ndef internal_instance(item):\n    if isinstance(item, str): return f'\"{item}\"'\n    elif isinstance(item, bool): return str(item).upper()\n    elif item is None: return DataType.NULL",
        "detail": "utils.data_utils",
        "documentation": {}
    },
    {
        "label": "is_array_of_type",
        "kind": 2,
        "importPath": "utils.data_utils",
        "description": "utils.data_utils",
        "peekOfCode": "def is_array_of_type(_array, _type):\n    return all(isinstance(elemento, _type) for elemento in _array)\ndef is_array_of_var(_array):\n    return all(isinstance(elem, str) and CompiledPatterns.VARIABLE.fullmatch(elem) for elem in _array)\ndef internal_instance(item):\n    if isinstance(item, str): return f'\"{item}\"'\n    elif isinstance(item, bool): return str(item).upper()\n    elif item is None: return DataType.NULL\n    elif isinstance(item, (dict, list)): return item\n    else:",
        "detail": "utils.data_utils",
        "documentation": {}
    },
    {
        "label": "is_array_of_var",
        "kind": 2,
        "importPath": "utils.data_utils",
        "description": "utils.data_utils",
        "peekOfCode": "def is_array_of_var(_array):\n    return all(isinstance(elem, str) and CompiledPatterns.VARIABLE.fullmatch(elem) for elem in _array)\ndef internal_instance(item):\n    if isinstance(item, str): return f'\"{item}\"'\n    elif isinstance(item, bool): return str(item).upper()\n    elif item is None: return DataType.NULL\n    elif isinstance(item, (dict, list)): return item\n    else:\n        return Return.NONE\ndef validate_date(map):",
        "detail": "utils.data_utils",
        "documentation": {}
    },
    {
        "label": "internal_instance",
        "kind": 2,
        "importPath": "utils.data_utils",
        "description": "utils.data_utils",
        "peekOfCode": "def internal_instance(item):\n    if isinstance(item, str): return f'\"{item}\"'\n    elif isinstance(item, bool): return str(item).upper()\n    elif item is None: return DataType.NULL\n    elif isinstance(item, (dict, list)): return item\n    else:\n        return Return.NONE\ndef validate_date(map):\n    keys = ('type', 'id', 'year', 'month', 'hour', 'minute', 'second', 'microsecond')\n    if not isinstance(map, dict): return",
        "detail": "utils.data_utils",
        "documentation": {}
    },
    {
        "label": "validate_date",
        "kind": 2,
        "importPath": "utils.data_utils",
        "description": "utils.data_utils",
        "peekOfCode": "def validate_date(map):\n    keys = ('type', 'id', 'year', 'month', 'hour', 'minute', 'second', 'microsecond')\n    if not isinstance(map, dict): return\n    if not all(key in map for key in keys): return\n    if map['type'] != 'date': return\n    return True\ndef is_empty(value):\n    if value is None:\n        return True\n    if isinstance(value, (str, list, dict, set)):",
        "detail": "utils.data_utils",
        "documentation": {}
    },
    {
        "label": "is_empty",
        "kind": 2,
        "importPath": "utils.data_utils",
        "description": "utils.data_utils",
        "peekOfCode": "def is_empty(value):\n    if value is None:\n        return True\n    if isinstance(value, (str, list, dict, set)):\n        return len(value) == 0\n    if isinstance(value, (int, float)):\n        return value == 0\n    if isinstance(value, re.Pattern):\n        return value.pattern == ''\n    return False",
        "detail": "utils.data_utils",
        "documentation": {}
    },
    {
        "label": "module_get_prop",
        "kind": 2,
        "importPath": "utils.data_utils",
        "description": "utils.data_utils",
        "peekOfCode": "def module_get_prop(key, cmd, props=False):\n    ref = rt.GLOBAL_COMMANDS.get(cmd, [0])\n    id = ref[0]\n    if rt.MODULES.get(id):\n        base = rt.MODULES[id].get(key)\n        result = base.get(cmd, None)\n        return result\ndef get_all_commands_old():\n    return Config.COMMANDS + list(rt.CUSTOM_COMMANDS) + list(rt.GLOBAL_COMMANDS)\ndef get_all_commands():",
        "detail": "utils.data_utils",
        "documentation": {}
    },
    {
        "label": "get_all_commands_old",
        "kind": 2,
        "importPath": "utils.data_utils",
        "description": "utils.data_utils",
        "peekOfCode": "def get_all_commands_old():\n    return Config.COMMANDS + list(rt.CUSTOM_COMMANDS) + list(rt.GLOBAL_COMMANDS)\ndef get_all_commands():\n    global _cached_commands, _cached_custom_commands, _cached_global_commands\n    # Verifica si CUSTOM_COMMANDS o GLOBAL_COMMANDS han cambiado\n    if (rt.CUSTOM_COMMANDS != _cached_custom_commands or \n        rt.GLOBAL_COMMANDS != _cached_global_commands):\n        # Actualiza la caché\n        _cached_custom_commands = list(rt.CUSTOM_COMMANDS)\n        _cached_global_commands = list(rt.GLOBAL_COMMANDS)",
        "detail": "utils.data_utils",
        "documentation": {}
    },
    {
        "label": "get_all_commands",
        "kind": 2,
        "importPath": "utils.data_utils",
        "description": "utils.data_utils",
        "peekOfCode": "def get_all_commands():\n    global _cached_commands, _cached_custom_commands, _cached_global_commands\n    # Verifica si CUSTOM_COMMANDS o GLOBAL_COMMANDS han cambiado\n    if (rt.CUSTOM_COMMANDS != _cached_custom_commands or \n        rt.GLOBAL_COMMANDS != _cached_global_commands):\n        # Actualiza la caché\n        _cached_custom_commands = list(rt.CUSTOM_COMMANDS)\n        _cached_global_commands = list(rt.GLOBAL_COMMANDS)\n        # Recalcula la lista de todos los comandos\n        _cached_commands = Config.COMMANDS.union(_cached_custom_commands, _cached_global_commands)",
        "detail": "utils.data_utils",
        "documentation": {}
    },
    {
        "label": "get_all_syntaxes",
        "kind": 2,
        "importPath": "utils.data_utils",
        "description": "utils.data_utils",
        "peekOfCode": "def get_all_syntaxes():\n    return Config.COMMAND_SYNTAXES + list(rt.CUSTOM_COMMANDS) + list(rt.GLOBAL_COMMANDS)\ndef extract_components(line): \n    line_parts = line.split('#', 3)  # Limitar la cantidad de splits\n    id = line_parts[1] if len(line_parts) > 1 else ''\n    line_number = int(line_parts[2]) if len(line_parts) > 2 else 0\n    line_content = line_parts[0].strip()\n    # Define structure\n    cmd, params = (line_content.split(' ', 1) + [None])[:2]\n    cmd = cmd.rstrip(';')",
        "detail": "utils.data_utils",
        "documentation": {}
    },
    {
        "label": "extract_components",
        "kind": 2,
        "importPath": "utils.data_utils",
        "description": "utils.data_utils",
        "peekOfCode": "def extract_components(line): \n    line_parts = line.split('#', 3)  # Limitar la cantidad de splits\n    id = line_parts[1] if len(line_parts) > 1 else ''\n    line_number = int(line_parts[2]) if len(line_parts) > 2 else 0\n    line_content = line_parts[0].strip()\n    # Define structure\n    cmd, params = (line_content.split(' ', 1) + [None])[:2]\n    cmd = cmd.rstrip(';')\n    return id, line_number, line_content, cmd, params\ndef extract_components_old(line): ",
        "detail": "utils.data_utils",
        "documentation": {}
    },
    {
        "label": "extract_components_old",
        "kind": 2,
        "importPath": "utils.data_utils",
        "description": "utils.data_utils",
        "peekOfCode": "def extract_components_old(line): \n    line_parts = line.split('#')\n    id = get_element(line_parts, 1, '')\n    line_number = int(get_element(line_parts, 2, 0))\n    line = get_element(line_parts, 0, '').strip()\n    # Define structure\n    line_sections = line.split(' ', 1)\n    cmd = line_sections[0].rstrip(';')\n    params = get_element(line_sections, 1, None)\n    return id, line_number, line, cmd, params",
        "detail": "utils.data_utils",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "utils.data_utils",
        "description": "utils.data_utils",
        "peekOfCode": "__all__ = [\n    \"get_element\",\n    \"is_array_of_type\",\n    \"is_array_of_var\",\n    \"internal_instance\",\n    \"validate_date\",\n    \"is_empty\",\n    \"module_get_prop\",\n    \"get_all_commands\",\n    \"extract_components\"",
        "detail": "utils.data_utils",
        "documentation": {}
    },
    {
        "label": "_cached_commands",
        "kind": 5,
        "importPath": "utils.data_utils",
        "description": "utils.data_utils",
        "peekOfCode": "_cached_commands = None\n_cached_custom_commands = None\n_cached_global_commands = None\ndef get_element(array_, index, default=None):\n    return array_[index] if 0 <= index < len(array_) else default\ndef is_array_of_type(_array, _type):\n    return all(isinstance(elemento, _type) for elemento in _array)\ndef is_array_of_var(_array):\n    return all(isinstance(elem, str) and CompiledPatterns.VARIABLE.fullmatch(elem) for elem in _array)\ndef internal_instance(item):",
        "detail": "utils.data_utils",
        "documentation": {}
    },
    {
        "label": "_cached_custom_commands",
        "kind": 5,
        "importPath": "utils.data_utils",
        "description": "utils.data_utils",
        "peekOfCode": "_cached_custom_commands = None\n_cached_global_commands = None\ndef get_element(array_, index, default=None):\n    return array_[index] if 0 <= index < len(array_) else default\ndef is_array_of_type(_array, _type):\n    return all(isinstance(elemento, _type) for elemento in _array)\ndef is_array_of_var(_array):\n    return all(isinstance(elem, str) and CompiledPatterns.VARIABLE.fullmatch(elem) for elem in _array)\ndef internal_instance(item):\n    if isinstance(item, str): return f'\"{item}\"'",
        "detail": "utils.data_utils",
        "documentation": {}
    },
    {
        "label": "_cached_global_commands",
        "kind": 5,
        "importPath": "utils.data_utils",
        "description": "utils.data_utils",
        "peekOfCode": "_cached_global_commands = None\ndef get_element(array_, index, default=None):\n    return array_[index] if 0 <= index < len(array_) else default\ndef is_array_of_type(_array, _type):\n    return all(isinstance(elemento, _type) for elemento in _array)\ndef is_array_of_var(_array):\n    return all(isinstance(elem, str) and CompiledPatterns.VARIABLE.fullmatch(elem) for elem in _array)\ndef internal_instance(item):\n    if isinstance(item, str): return f'\"{item}\"'\n    elif isinstance(item, bool): return str(item).upper()",
        "detail": "utils.data_utils",
        "documentation": {}
    },
    {
        "label": "file_read",
        "kind": 2,
        "importPath": "utils.file_utils",
        "description": "utils.file_utils",
        "peekOfCode": "def file_read(filename, error = False):\n    if file_exists(filename, error):\n        # Abrir el archivo en modo lectura ('r') con la codificación UTF-8\n        with io.open(filename, mode='r', encoding='utf-8') as f:\n            # Leer el contenido del archivo y devolverlo como una cadena\n            content = f.read()\n            #decoded_content = content.encode('unicode-escape').decode('utf-8')\n            return content\n    return None\n    if (file_exists(filename, error)):",
        "detail": "utils.file_utils",
        "documentation": {}
    },
    {
        "label": "file_exists",
        "kind": 2,
        "importPath": "utils.file_utils",
        "description": "utils.file_utils",
        "peekOfCode": "def file_exists(filename, error = False):\n    result = os.path.isfile(filename)\n    if error and not result:\n        throw(e.FILE_NOT_FOUND, [filename])\n    return result\ndef dir_files(path):\n    onlyfiles = [f for f in os.listdir(path) if os.path.isfile(os.path.join(path, f))]\ndef wpath(file_name):\n    if os.path.isabs(file_name):\n        return file_name",
        "detail": "utils.file_utils",
        "documentation": {}
    },
    {
        "label": "dir_files",
        "kind": 2,
        "importPath": "utils.file_utils",
        "description": "utils.file_utils",
        "peekOfCode": "def dir_files(path):\n    onlyfiles = [f for f in os.listdir(path) if os.path.isfile(os.path.join(path, f))]\ndef wpath(file_name):\n    if os.path.isabs(file_name):\n        return file_name\n    else:\n        base_path = rt.working_path\n        return os.path.join(base_path, file_name)\ndef rpath(file_name):\n    return os.path.relpath(file_name, rt.working_path)",
        "detail": "utils.file_utils",
        "documentation": {}
    },
    {
        "label": "wpath",
        "kind": 2,
        "importPath": "utils.file_utils",
        "description": "utils.file_utils",
        "peekOfCode": "def wpath(file_name):\n    if os.path.isabs(file_name):\n        return file_name\n    else:\n        base_path = rt.working_path\n        return os.path.join(base_path, file_name)\ndef rpath(file_name):\n    return os.path.relpath(file_name, rt.working_path)",
        "detail": "utils.file_utils",
        "documentation": {}
    },
    {
        "label": "rpath",
        "kind": 2,
        "importPath": "utils.file_utils",
        "description": "utils.file_utils",
        "peekOfCode": "def rpath(file_name):\n    return os.path.relpath(file_name, rt.working_path)",
        "detail": "utils.file_utils",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "utils.file_utils",
        "description": "utils.file_utils",
        "peekOfCode": "__all__ = ['file_read', 'file_exists', 'wpath', 'rpath']\ndef file_read(filename, error = False):\n    if file_exists(filename, error):\n        # Abrir el archivo en modo lectura ('r') con la codificación UTF-8\n        with io.open(filename, mode='r', encoding='utf-8') as f:\n            # Leer el contenido del archivo y devolverlo como una cadena\n            content = f.read()\n            #decoded_content = content.encode('unicode-escape').decode('utf-8')\n            return content\n    return None",
        "detail": "utils.file_utils",
        "documentation": {}
    },
    {
        "label": "clean_line",
        "kind": 2,
        "importPath": "utils.string_utils copy",
        "description": "utils.string_utils copy",
        "peekOfCode": "def clean_line(line):\n    line = line.strip()\n    line = line.split('#')[0].strip() # Delete comments\n    return line\n# Count indentation (number of spaces or tabs)\n@cache()\ndef count_indentation(line):\n    count = 0\n    for char in line:\n        if char == ' ':",
        "detail": "utils.string_utils copy",
        "documentation": {}
    },
    {
        "label": "count_indentation",
        "kind": 2,
        "importPath": "utils.string_utils copy",
        "description": "utils.string_utils copy",
        "peekOfCode": "def count_indentation(line):\n    count = 0\n    for char in line:\n        if char == ' ':\n            count += 1\n        elif char == '\\t':\n            count += 4  # Assuming each tab is equivalent to 4 spaces\n        else:\n            break\n    if count % 4 != 0:",
        "detail": "utils.string_utils copy",
        "documentation": {}
    },
    {
        "label": "input_text",
        "kind": 2,
        "importPath": "utils.string_utils copy",
        "description": "utils.string_utils copy",
        "peekOfCode": "def input_text(text = '', hard = False):\n    combined_pattern = re.compile(f\"{Patterns.STRING}|{Patterns.ESCAPED_STRING}\")\n    def replace_char(match):\n        matched_string = match.group(0)\n        if matched_string.startswith('!'):\n            sign = matched_string[1]\n            matched_string = matched_string[2:-1]\n        else:\n            sign = matched_string[0]\n            matched_string = matched_string[1:-1]",
        "detail": "utils.string_utils copy",
        "documentation": {}
    },
    {
        "label": "output_text_old",
        "kind": 2,
        "importPath": "utils.string_utils copy",
        "description": "utils.string_utils copy",
        "peekOfCode": "def output_text_old(text = ''):\n    pattern = [\n        #[Config.CHAR_BREAKLINE, '\\u000A'], \n        [Config.CHAR_PIPE, '|'],\n        [Config.CHAR_DDSL, r'\\\\'],\n        [Config.CHAR_HASH, '#'],\n        [Config.CHAR_DQUOTE, \"\\\"\"],\n        [Config.CHAR_SQUOTE, \"'\"],\n        # [Config.CHAR_DOLLAR, \"$\"],\n        # [Config.CHAR_AT, \"@\"],",
        "detail": "utils.string_utils copy",
        "documentation": {}
    },
    {
        "label": "output_text",
        "kind": 2,
        "importPath": "utils.string_utils copy",
        "description": "utils.string_utils copy",
        "peekOfCode": "def output_text(text):\n    for i, special_char in enumerate(Config.SPECIAL_CHARS):\n        text = text.replace(chr(0xFFF0 + i), special_char)\n    return text\ndef output_textx(text=''):\n    # Crear el diccionario de traducción usando str.maketrans\n    translation_table = str.maketrans(replace_dict)\n    # Aplicar la traducción al texto\n    translated_text = text.translate(translation_table)\n    return translated_text",
        "detail": "utils.string_utils copy",
        "documentation": {}
    },
    {
        "label": "output_textx",
        "kind": 2,
        "importPath": "utils.string_utils copy",
        "description": "utils.string_utils copy",
        "peekOfCode": "def output_textx(text=''):\n    # Crear el diccionario de traducción usando str.maketrans\n    translation_table = str.maketrans(replace_dict)\n    # Aplicar la traducción al texto\n    translated_text = text.translate(translation_table)\n    return translated_text\ndef core_print(match):\n    value = match.group(0)\n    if value.lower() in ('true', 'false', 'null'):\n        return value.upper()",
        "detail": "utils.string_utils copy",
        "documentation": {}
    },
    {
        "label": "core_print",
        "kind": 2,
        "importPath": "utils.string_utils copy",
        "description": "utils.string_utils copy",
        "peekOfCode": "def core_print(match):\n    value = match.group(0)\n    if value.lower() in ('true', 'false', 'null'):\n        return value.upper()\n    elif value.lower() == 'none':\n        return 'NULL'\n    else:\n        print(\"OK\", value)\n@hcache()\ndef type_name(data):",
        "detail": "utils.string_utils copy",
        "documentation": {}
    },
    {
        "label": "type_name",
        "kind": 2,
        "importPath": "utils.string_utils copy",
        "description": "utils.string_utils copy",
        "peekOfCode": "def type_name(data):\n    _type = type(data).__name__\n    match (_type):\n        case 'str': return DataType.STRING\n        case 'int': return DataType.NUMBER\n        case 'float': return DataType.NUMBER\n        case 'list': return DataType.ARRAY\n        case 'dict': return DataType.MAP\n        case 'bool': return DataType.BOOL\n        case 'NoneType': return DataType.NULL",
        "detail": "utils.string_utils copy",
        "documentation": {}
    },
    {
        "label": "decode_text",
        "kind": 2,
        "importPath": "utils.string_utils copy",
        "description": "utils.string_utils copy",
        "peekOfCode": "def decode_text(text: str):\n    text = str(text).encode('ascii', 'backslashreplace').decode('unicode_escape', 'namereplace')\n    return text\ndef validate_url(url):\n    return bool(re.fullmatch(r\"(https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9]+\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]+\\.[^\\s]{2,})\", url))",
        "detail": "utils.string_utils copy",
        "documentation": {}
    },
    {
        "label": "validate_url",
        "kind": 2,
        "importPath": "utils.string_utils copy",
        "description": "utils.string_utils copy",
        "peekOfCode": "def validate_url(url):\n    return bool(re.fullmatch(r\"(https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9]+\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]+\\.[^\\s]{2,})\", url))",
        "detail": "utils.string_utils copy",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "utils.string_utils copy",
        "description": "utils.string_utils copy",
        "peekOfCode": "__all__ = ['clean_line', 'count_indentation', 'output_text', 'core_print', 'type_name', 'input_text', 'decode_text', 'validate_url']\n# Clean line from comments\ndef clean_line(line):\n    line = line.strip()\n    line = line.split('#')[0].strip() # Delete comments\n    return line\n# Count indentation (number of spaces or tabs)\n@cache()\ndef count_indentation(line):\n    count = 0",
        "detail": "utils.string_utils copy",
        "documentation": {}
    },
    {
        "label": "clean_line",
        "kind": 2,
        "importPath": "utils.string_utils",
        "description": "utils.string_utils",
        "peekOfCode": "def clean_line(line:str):\n    return line.strip().split('#')[0].strip()\n# Count indentation (number of spaces or tabs)\n@cache()\ndef count_indentation(line):\n    count = 0\n    for char in line:\n        if char == ' ':\n            count += 1\n        elif char == '\\t':",
        "detail": "utils.string_utils",
        "documentation": {}
    },
    {
        "label": "count_indentation",
        "kind": 2,
        "importPath": "utils.string_utils",
        "description": "utils.string_utils",
        "peekOfCode": "def count_indentation(line):\n    count = 0\n    for char in line:\n        if char == ' ':\n            count += 1\n        elif char == '\\t':\n            count += 4  # Assuming each tab is equivalent to 4 spaces\n        else:\n            break\n    if count % 4 != 0:",
        "detail": "utils.string_utils",
        "documentation": {}
    },
    {
        "label": "input_text",
        "kind": 2,
        "importPath": "utils.string_utils",
        "description": "utils.string_utils",
        "peekOfCode": "def input_text(text = '', hard = False):\n    for i, char in enumerate(Config.SPECIAL_CHARS):\n        if char in text:\n            text = text.replace(char, chr(0xFFF0 + i))\n    return text\n@cache()\ndef output_text(text):\n    for i, special_char in enumerate(Config.SPECIAL_CHARS):\n        text = text.replace(chr(0xFFF0 + i), special_char)\n    return text",
        "detail": "utils.string_utils",
        "documentation": {}
    },
    {
        "label": "output_text",
        "kind": 2,
        "importPath": "utils.string_utils",
        "description": "utils.string_utils",
        "peekOfCode": "def output_text(text):\n    for i, special_char in enumerate(Config.SPECIAL_CHARS):\n        text = text.replace(chr(0xFFF0 + i), special_char)\n    return text\n@hcache()\ndef type_name(data):\n    _type = type(data).__name__\n    match (_type):\n        case 'str': return DataType.STRING\n        case 'int': return DataType.NUMBER",
        "detail": "utils.string_utils",
        "documentation": {}
    },
    {
        "label": "type_name",
        "kind": 2,
        "importPath": "utils.string_utils",
        "description": "utils.string_utils",
        "peekOfCode": "def type_name(data):\n    _type = type(data).__name__\n    match (_type):\n        case 'str': return DataType.STRING\n        case 'int': return DataType.NUMBER\n        case 'float': return DataType.NUMBER\n        case 'list': return DataType.ARRAY\n        case 'dict': return DataType.MAP\n        case 'bool': return DataType.BOOL\n        case 'NoneType': return DataType.NULL",
        "detail": "utils.string_utils",
        "documentation": {}
    },
    {
        "label": "decode_text",
        "kind": 2,
        "importPath": "utils.string_utils",
        "description": "utils.string_utils",
        "peekOfCode": "def decode_text(text: str):\n    text = str(text).encode('ascii', 'backslashreplace').decode('unicode_escape', 'namereplace')\n    return text\ndef validate_url(url):\n    return bool(re.fullmatch(r\"(https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9]+\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]+\\.[^\\s]{2,})\", url))\ndef to_string(data, format=False):\n    def replace(match):\n        value = match.group(0).lower()\n        if value in ('true', 'false', 'null'):\n            return value.upper()",
        "detail": "utils.string_utils",
        "documentation": {}
    },
    {
        "label": "validate_url",
        "kind": 2,
        "importPath": "utils.string_utils",
        "description": "utils.string_utils",
        "peekOfCode": "def validate_url(url):\n    return bool(re.fullmatch(r\"(https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9]+\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]+\\.[^\\s]{2,})\", url))\ndef to_string(data, format=False):\n    def replace(match):\n        value = match.group(0).lower()\n        if value in ('true', 'false', 'null'):\n            return value.upper()\n        elif value == 'none':\n            return DataType.NULL\n        elif value == 'infinity':",
        "detail": "utils.string_utils",
        "documentation": {}
    },
    {
        "label": "to_string",
        "kind": 2,
        "importPath": "utils.string_utils",
        "description": "utils.string_utils",
        "peekOfCode": "def to_string(data, format=False):\n    def replace(match):\n        value = match.group(0).lower()\n        if value in ('true', 'false', 'null'):\n            return value.upper()\n        elif value == 'none':\n            return DataType.NULL\n        elif value == 'infinity':\n            return KW.INFINITY\n        elif value == 'nan':",
        "detail": "utils.string_utils",
        "documentation": {}
    },
    {
        "label": "splitc",
        "kind": 2,
        "importPath": "utils.string_utils",
        "description": "utils.string_utils",
        "peekOfCode": "def splitc(string, delimiter):\n    return string.split(delimiter)",
        "detail": "utils.string_utils",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "utils.string_utils",
        "description": "utils.string_utils",
        "peekOfCode": "__all__ = [\n    \"clean_line\",\n    \"count_indentation\",\n    \"output_text\",\n    \"type_name\",\n    \"input_text\",\n    \"decode_text\",\n    \"validate_url\",\n    \"to_string\",\n    \"get_flag\",",
        "detail": "utils.string_utils",
        "documentation": {}
    },
    {
        "label": "FLAG_MAP",
        "kind": 5,
        "importPath": "utils.string_utils",
        "description": "utils.string_utils",
        "peekOfCode": "FLAG_MAP = {\n    re.ASCII: 'a',\n    re.IGNORECASE: 'i',\n    re.LOCALE: 'l',\n    re.MULTILINE: 'm',\n    re.DOTALL: 's',\n    re.UNICODE: 'u',\n    re.VERBOSE: 'x',\n}\n@cache()",
        "detail": "utils.string_utils",
        "documentation": {}
    },
    {
        "label": "VariableCache",
        "kind": 6,
        "importPath": "utils.vars_utils copy",
        "description": "utils.vars_utils copy",
        "peekOfCode": "class VariableCache:\n    def __init__(self):\n        self._cache = {}\n        self._timestamps = {}\n    def _get_current_time(self):\n        return time.time()\n    def _invalidate_cache(self, key):\n        if key in self._cache:\n            del self._cache[key]\n        if key in self._timestamps:",
        "detail": "utils.vars_utils copy",
        "documentation": {}
    },
    {
        "label": "envar_set",
        "kind": 2,
        "importPath": "utils.vars_utils copy",
        "description": "utils.vars_utils copy",
        "peekOfCode": "def envar_set(varname: str, value = None):\n    varname = varname.strip('$@')\n    rt.envars[varname] = value\ndef envar_get(varname: str):\n    var = varname.strip('@')\n    root = get_element(var.split('.', 1), 0, '')\n    if not root in rt.supported_envars:\n        throw(e.UNKNOWN_ENVAR, [varname])\n    if '.' in var:\n        env = get_nested_value(rt.envars, var)",
        "detail": "utils.vars_utils copy",
        "documentation": {}
    },
    {
        "label": "envar_get",
        "kind": 2,
        "importPath": "utils.vars_utils copy",
        "description": "utils.vars_utils copy",
        "peekOfCode": "def envar_get(varname: str):\n    var = varname.strip('@')\n    root = get_element(var.split('.', 1), 0, '')\n    if not root in rt.supported_envars:\n        throw(e.UNKNOWN_ENVAR, [varname])\n    if '.' in var:\n        env = get_nested_value(rt.envars, var)\n    elif var == f'{Envar.SELF}':\n        return None\n    else:",
        "detail": "utils.vars_utils copy",
        "documentation": {}
    },
    {
        "label": "envars_reset",
        "kind": 2,
        "importPath": "utils.vars_utils copy",
        "description": "utils.vars_utils copy",
        "peekOfCode": "def envars_reset():\n    #rt.envars.clear()\n    for x in Config.ENVARS_RESETTABLE:\n        envar_set(x)\n# Variables\ndef var_set(varname, value = None, set_global=False):\n    sign = varname[0]\n    var_name = varname.strip('$@')\n    # Avoid modifying environment variables\n    if sign == '@': throw(e.PROTECTED_ENVARS)",
        "detail": "utils.vars_utils copy",
        "documentation": {}
    },
    {
        "label": "var_set",
        "kind": 2,
        "importPath": "utils.vars_utils copy",
        "description": "utils.vars_utils copy",
        "peekOfCode": "def var_set(varname, value = None, set_global=False):\n    sign = varname[0]\n    var_name = varname.strip('$@')\n    # Avoid modifying environment variables\n    if sign == '@': throw(e.PROTECTED_ENVARS)\n    # Use cache manager to set value\n    cache_manager.set(var_name, value, set_global=set_global)\n    return\n    return set_nested_value(var_name, value, set_global=set_global)\ndef var_get(varname, error = True, origin = None):",
        "detail": "utils.vars_utils copy",
        "documentation": {}
    },
    {
        "label": "var_get",
        "kind": 2,
        "importPath": "utils.vars_utils copy",
        "description": "utils.vars_utils copy",
        "peekOfCode": "def var_get(varname, error = True, origin = None):\n    #show(cache_manager._cache)\n    if len(varname) < 2:\n        throw(e.INVALID_TS_VARNAME, [varname])\n    sign = varname[0]\n    var = varname[1:]\n    # Get environment variables\n    if sign == '@':\n        value = envar_get(var)\n        if value == Return.NONE:",
        "detail": "utils.vars_utils copy",
        "documentation": {}
    },
    {
        "label": "var_gext",
        "kind": 2,
        "importPath": "utils.vars_utils copy",
        "description": "utils.vars_utils copy",
        "peekOfCode": "def var_gext(varname, error = True):\n    if len(varname) < 2:\n        throw(e.INVALID_TS_VARNAME, [varname])\n    sign = varname[0]\n    var = varname[1:]\n    # Get environment variables\n    if sign == '@':\n        value = envar_get(var)\n        if value == Return.NONE:\n            throw(e.UNKNOWN_VAR, [varname])",
        "detail": "utils.vars_utils copy",
        "documentation": {}
    },
    {
        "label": "var_exists",
        "kind": 2,
        "importPath": "utils.vars_utils copy",
        "description": "utils.vars_utils copy",
        "peekOfCode": "def var_exists(varname):\n    result = var_get(varname, False)\n    return result != Return.NONE\ndef var_unset(varname):\n    sign = varname[0]\n    var = varname[1:]\n    # Check var first\n    var_get(varname)\n    if var.count('.'):\n        throw(e.UNSET_NESTED_KEYS, [var.split('.',1)[0], var])",
        "detail": "utils.vars_utils copy",
        "documentation": {}
    },
    {
        "label": "var_unset",
        "kind": 2,
        "importPath": "utils.vars_utils copy",
        "description": "utils.vars_utils copy",
        "peekOfCode": "def var_unset(varname):\n    sign = varname[0]\n    var = varname[1:]\n    # Check var first\n    var_get(varname)\n    if var.count('.'):\n        throw(e.UNSET_NESTED_KEYS, [var.split('.',1)[0], var])\n    if sign == '@':\n        throw(e.PROTECTED_ENVARS)\n    try:",
        "detail": "utils.vars_utils copy",
        "documentation": {}
    },
    {
        "label": "get_nested_value",
        "kind": 2,
        "importPath": "utils.vars_utils copy",
        "description": "utils.vars_utils copy",
        "peekOfCode": "def get_nested_value(root, key):\n    keys = key.split('.')\n    value = root\n    for k in keys:\n        if isinstance(value, dict) and k in value:\n                value = value[k]\n            # else:\n            #     print(f\"Value: {value} | K: {k}\")\n            #     throw(e.UNKNOWN_KEY, [k])\n        elif isinstance(value, list):",
        "detail": "utils.vars_utils copy",
        "documentation": {}
    },
    {
        "label": "set_nested_value",
        "kind": 2,
        "importPath": "utils.vars_utils copy",
        "description": "utils.vars_utils copy",
        "peekOfCode": "def set_nested_value(key, value, set_global=False):\n    keys = key.split('.')\n    if set_global:\n        current_scope = rt.global_variables\n    else:\n        current_scope = get_scope(key)\n    for i, k in enumerate(keys):\n        if isinstance(current_scope, dict):\n            if i == len(keys) - 1:\n                # Último nivel, asignar el valor",
        "detail": "utils.vars_utils copy",
        "documentation": {}
    },
    {
        "label": "get_scope",
        "kind": 2,
        "importPath": "utils.vars_utils copy",
        "description": "utils.vars_utils copy",
        "peekOfCode": "def get_scope(key):\n    current_scope = None\n    block = rt.current_block\n    while block is not None:\n        if key in block['variables']:\n            current_scope = block['variables']\n            break\n        block = block['parent']\n    if current_scope is None:\n        # Si no se encontró en ningún scope, crear una nueva variable en el scope actual",
        "detail": "utils.vars_utils copy",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "utils.vars_utils copy",
        "description": "utils.vars_utils copy",
        "peekOfCode": "__all__ = ['envar_set', 'envar_get', 'envars_reset', 'var_set', 'var_get', 'var_unset', 'var_exists']\nimport time\nclass VariableCache:\n    def __init__(self):\n        self._cache = {}\n        self._timestamps = {}\n    def _get_current_time(self):\n        return time.time()\n    def _invalidate_cache(self, key):\n        if key in self._cache:",
        "detail": "utils.vars_utils copy",
        "documentation": {}
    },
    {
        "label": "cache_manager",
        "kind": 5,
        "importPath": "utils.vars_utils copy",
        "description": "utils.vars_utils copy",
        "peekOfCode": "cache_manager = VariableCache()\n# Ejemplo de uso\ncache = VariableCache()\n# Envars\ndef envar_set(varname: str, value = None):\n    varname = varname.strip('$@')\n    rt.envars[varname] = value\ndef envar_get(varname: str):\n    var = varname.strip('@')\n    root = get_element(var.split('.', 1), 0, '')",
        "detail": "utils.vars_utils copy",
        "documentation": {}
    },
    {
        "label": "cache",
        "kind": 5,
        "importPath": "utils.vars_utils copy",
        "description": "utils.vars_utils copy",
        "peekOfCode": "cache = VariableCache()\n# Envars\ndef envar_set(varname: str, value = None):\n    varname = varname.strip('$@')\n    rt.envars[varname] = value\ndef envar_get(varname: str):\n    var = varname.strip('@')\n    root = get_element(var.split('.', 1), 0, '')\n    if not root in rt.supported_envars:\n        throw(e.UNKNOWN_ENVAR, [varname])",
        "detail": "utils.vars_utils copy",
        "documentation": {}
    },
    {
        "label": "envar_set",
        "kind": 2,
        "importPath": "utils.vars_utils",
        "description": "utils.vars_utils",
        "peekOfCode": "def envar_set(varname: str, value = None):\n    varname = varname.strip('$@')\n    rt.envars[varname] = value\ndef envar_get(varname: str):\n    var = varname.strip('@')\n    root = get_element(var.split('.', 1), 0, '')\n    if not root in rt.supported_envars:\n        throw(e.UNKNOWN_ENVAR, [varname])\n    if '.' in var:\n        env = get_nested_value(rt.envars, var)",
        "detail": "utils.vars_utils",
        "documentation": {}
    },
    {
        "label": "envar_get",
        "kind": 2,
        "importPath": "utils.vars_utils",
        "description": "utils.vars_utils",
        "peekOfCode": "def envar_get(varname: str):\n    var = varname.strip('@')\n    root = get_element(var.split('.', 1), 0, '')\n    if not root in rt.supported_envars:\n        throw(e.UNKNOWN_ENVAR, [varname])\n    if '.' in var:\n        env = get_nested_value(rt.envars, var)\n    elif var == f'{Envar.SELF}':\n        return None\n    else:",
        "detail": "utils.vars_utils",
        "documentation": {}
    },
    {
        "label": "envars_reset",
        "kind": 2,
        "importPath": "utils.vars_utils",
        "description": "utils.vars_utils",
        "peekOfCode": "def envars_reset():\n    #rt.envars.clear()\n    for x in Config.ENVARS_RESETTABLE:\n        envar_set(x)\n# Variables\ndef var_set(varname, value = None, set_global=False):\n    sign = varname[0]\n    var_name = varname.strip('$@')\n    # Avoid modifying environment variables\n    if sign == '@': throw(e.PROTECTED_ENVARS)",
        "detail": "utils.vars_utils",
        "documentation": {}
    },
    {
        "label": "var_set",
        "kind": 2,
        "importPath": "utils.vars_utils",
        "description": "utils.vars_utils",
        "peekOfCode": "def var_set(varname, value = None, set_global=False):\n    sign = varname[0]\n    var_name = varname.strip('$@')\n    # Avoid modifying environment variables\n    if sign == '@': throw(e.PROTECTED_ENVARS)\n    return set_nested_value(var_name, value, set_global=set_global)\ndef var_get(varname, error = True, origin = None):\n    if len(varname) < 2:\n        throw(e.INVALID_TS_VARNAME, [varname])\n    sign = varname[0]",
        "detail": "utils.vars_utils",
        "documentation": {}
    },
    {
        "label": "var_get",
        "kind": 2,
        "importPath": "utils.vars_utils",
        "description": "utils.vars_utils",
        "peekOfCode": "def var_get(varname, error = True, origin = None):\n    if len(varname) < 2:\n        throw(e.INVALID_TS_VARNAME, [varname])\n    sign = varname[0]\n    var = varname[1:]\n    # Get environment variables\n    if sign == '@':\n        value = envar_get(var)\n        if value == Return.NONE:\n            throw(e.UNKNOWN_VAR, [varname])",
        "detail": "utils.vars_utils",
        "documentation": {}
    },
    {
        "label": "var_gext",
        "kind": 2,
        "importPath": "utils.vars_utils",
        "description": "utils.vars_utils",
        "peekOfCode": "def var_gext(varname, error = True):\n    if len(varname) < 2:\n        throw(e.INVALID_TS_VARNAME, [varname])\n    sign = varname[0]\n    var = varname[1:]\n    # Get environment variables\n    if sign == '@':\n        value = envar_get(var)\n        if value == Return.NONE:\n            throw(e.UNKNOWN_VAR, [varname])",
        "detail": "utils.vars_utils",
        "documentation": {}
    },
    {
        "label": "var_exists",
        "kind": 2,
        "importPath": "utils.vars_utils",
        "description": "utils.vars_utils",
        "peekOfCode": "def var_exists(varname):\n    result = var_get(varname, False)\n    return result != Return.NONE\ndef var_unset(varname):\n    sign = varname[0]\n    var = varname[1:]\n    # Check var first\n    var_get(varname)\n    if var.count('.'):\n        throw(e.UNSET_NESTED_KEYS, [var.split('.',1)[0], var])",
        "detail": "utils.vars_utils",
        "documentation": {}
    },
    {
        "label": "var_unset",
        "kind": 2,
        "importPath": "utils.vars_utils",
        "description": "utils.vars_utils",
        "peekOfCode": "def var_unset(varname):\n    sign = varname[0]\n    var = varname[1:]\n    # Check var first\n    var_get(varname)\n    if var.count('.'):\n        throw(e.UNSET_NESTED_KEYS, [var.split('.',1)[0], var])\n    if sign == '@':\n        throw(e.PROTECTED_ENVARS)\n    try:",
        "detail": "utils.vars_utils",
        "documentation": {}
    },
    {
        "label": "get_nested_value",
        "kind": 2,
        "importPath": "utils.vars_utils",
        "description": "utils.vars_utils",
        "peekOfCode": "def get_nested_value(root, key):\n    keys = key.split('.')\n    value = root\n    for k in keys:\n        if isinstance(value, dict) and k in value:\n                value = value[k]\n            # else:\n            #     print(f\"Value: {value} | K: {k}\")\n            #     throw(e.UNKNOWN_KEY, [k])\n        elif isinstance(value, list):",
        "detail": "utils.vars_utils",
        "documentation": {}
    },
    {
        "label": "set_nested_value",
        "kind": 2,
        "importPath": "utils.vars_utils",
        "description": "utils.vars_utils",
        "peekOfCode": "def set_nested_value(key, value, set_global=False):\n    keys = key.split('.')\n    if set_global:\n        current_scope = rt.global_variables\n    else:\n        current_scope = get_scope(key)\n    for i, k in enumerate(keys):\n        if isinstance(current_scope, dict):\n            if i == len(keys) - 1:\n                # Último nivel, asignar el valor",
        "detail": "utils.vars_utils",
        "documentation": {}
    },
    {
        "label": "get_scope",
        "kind": 2,
        "importPath": "utils.vars_utils",
        "description": "utils.vars_utils",
        "peekOfCode": "def get_scope(key):\n    current_scope = None\n    block = rt.current_block\n    while block is not None:\n        if key in block['variables']:\n            current_scope = block['variables']\n            break\n        block = block['parent']\n    if current_scope is None:\n        # Si no se encontró en ningún scope, crear una nueva variable en el scope actual",
        "detail": "utils.vars_utils",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "utils.vars_utils",
        "description": "utils.vars_utils",
        "peekOfCode": "__all__ = ['envar_set', 'envar_get', 'envars_reset', 'var_set', 'var_get', 'var_unset', 'var_exists']\n# Envars\ndef envar_set(varname: str, value = None):\n    varname = varname.strip('$@')\n    rt.envars[varname] = value\ndef envar_get(varname: str):\n    var = varname.strip('@')\n    root = get_element(var.split('.', 1), 0, '')\n    if not root in rt.supported_envars:\n        throw(e.UNKNOWN_ENVAR, [varname])",
        "detail": "utils.vars_utils",
        "documentation": {}
    }
]